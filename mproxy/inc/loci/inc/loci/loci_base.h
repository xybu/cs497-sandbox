/* Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University */
/* Copyright (c) 2011, 2012 Open Networking Foundation */
/* Copyright (c) 2012, 2013 Big Switch Networks, Inc. */
/* See the file LICENSE.loci which should have been included in the source distribution */

/****************************************************************
 * File: loci_base.h
 *
 * DO NOT EDIT
 *
 * This file is automatically generated
 *
 ****************************************************************/


#if !defined(_LOCI_BASE_H_)
#define _LOCI_BASE_H_


/*
 * Base OpenFlow definitions.  These depend only on standard C headers
 */
#include <string.h>
#include <stdint.h>

/* g++ requires this to pick up PRI, etc.
 * See  http://gcc.gnu.org/ml/gcc-help/2006-10/msg00223.html
 */
#if !defined(__STDC_FORMAT_MACROS)
#define __STDC_FORMAT_MACROS
#endif
#include <inttypes.h>

#include <stdlib.h>
#include <assert.h>
#include <loci/loci_idents.h>

/**
 * Macro to enable debugging for LOCI.
 *
 * This enables debug output to stdout.
 */
#define OF_DEBUG_ENABLE

#if defined(OF_DEBUG_ENABLE)
#include <stdio.h> /* Currently for debugging */
#define FIXME(str) do {                 \
        fprintf(stderr, "%s\n", str);  \
        exit(1);                        \
    } while (0)
#define debug printf
#else
#define FIXME(str)
#define debug(str, ...)
#endif /* OF_DEBUG_ENABLE */

/**
 * The type of a function used by the LOCI dump/show functions to
 * output text. Essentially the same signature as fprintf. May
 * be called many times per invocation of e.g. of_object_show().
 */
typedef int (*loci_writer_f)(void *cookie, const char *fmt, ...);

/**
 * Check if a version is supported
 */
#define OF_VERSION_OKAY(v) ((v) >= OF_VERSION_1_0 && (v) <= OF_VERSION_1_4)


/**
 * Enumeration of OpenFlow versions
 *
 * The wire protocol numbers are currently used for values of the corresponding
 * version identifiers.
 */
typedef enum of_version_e {
    OF_VERSION_UNKNOWN = 0,
    OF_VERSION_1_0 = 1,
    OF_VERSION_1_1 = 2,
    OF_VERSION_1_2 = 3,
    OF_VERSION_1_3 = 4,
    OF_VERSION_1_4 = 5
} of_version_t;

/**
 * @brief Use this when declaring arrays indexed by wire version
 */
#define OF_VERSION_ARRAY_MAX 6


typedef enum of_error_codes_e {
    OF_ERROR_NONE        = 0,
    OF_ERROR_RESOURCE    = -1,    /* Could not allocate space */
    OF_ERROR_PARAM       = -2,    /* Bad parameter */
    OF_ERROR_VERSION     = -3,    /* Version not supported */
    OF_ERROR_RANGE       = -4,    /* End of list indication */
    OF_ERROR_COMPAT      = -5,    /* Incompatible assignment */
    OF_ERROR_PARSE       = -6,    /* Error in parsing data */
    OF_ERROR_INIT        = -7,    /* Uninitialized data */
    OF_ERROR_UNKNOWN     = -8     /* Unknown error */
} of_error_codes_t;

#define OF_ERROR_STRINGS "none", \
    "resource", \
    "parameter", \
    "version", \
    "range", \
    "incompatible", \
    "parse", \
    "init", \
    "unknown"

extern const char *const of_error_strings[];

#ifdef __GNUC__
#define LOCI_NORETURN_ATTR __attribute__((__noreturn__))
#else
#define LOCI_NORETURN_ATTR
#endif

extern void loci_assert_fail(
    const char *cond,
    const char *file,
    unsigned int line) LOCI_NORETURN_ATTR;

#ifndef NDEBUG
#define LOCI_ASSERT(val) ((val) ? (void)0 : loci_assert_fail(#val, __FILE__, __LINE__))
#else
#define LOCI_ASSERT(val)
#endif

/*
 * Some LOCI object accessors can fail, and it's easy to forget to check.
 * On certain compilers we can trigger a warning if the error code
 * is ignored.
 */
#ifndef DISABLE_WARN_UNUSED_RESULT
#ifdef __GNUC__
#define WARN_UNUSED_RESULT __attribute__ ((warn_unused_result))
#else
#define WARN_UNUSED_RESULT
#endif
#else
#define WARN_UNUSED_RESULT
#endif

typedef union of_generic_u of_generic_t;
typedef struct of_object_s of_object_t;

/* Define ipv4 address as uint32 */
typedef uint32_t of_ipv4_t;

/* Table ID is the OF standard uint8 */
typedef uint8_t of_table_id_t;

#define OF_MAC_ADDR_BYTES 6
typedef struct of_mac_addr_s {
   uint8_t addr[OF_MAC_ADDR_BYTES];
} of_mac_addr_t;

#define OF_IPV6_BYTES 16
typedef struct of_ipv6_s {
   uint8_t addr[OF_IPV6_BYTES];
} of_ipv6_t;

typedef struct of_bitmap_512_s {
    uint64_t words[8];
} of_bitmap_512_t;

extern const of_mac_addr_t of_mac_addr_all_ones;
extern const of_mac_addr_t of_mac_addr_all_zeros;

extern const of_ipv6_t of_ipv6_all_ones;
extern const of_ipv6_t of_ipv6_all_zeros;

extern const of_bitmap_512_t of_bitmap_512_all_ones;
extern const of_bitmap_512_t of_bitmap_512_all_zeroes;

/**
 * Generic zero and all-ones values of size 16 bytes.
 *
 * bitmap_512 is longest data type we worry about for comparisons
 */
#define of_all_zero_value of_bitmap_512_all_zeroes
#define of_all_ones_value of_bitmap_512_all_ones

/**
 * Non-zero/all ones check for arbitrary type of size <= 16 bytes
 */
#define OF_VARIABLE_IS_NON_ZERO(_ptr) \
    (MEMCMP(&of_all_zero_value, (_ptr), sizeof(*(_ptr))))
#define OF_VARIABLE_IS_ALL_ONES(_ptr) \
    (!MEMCMP(&of_all_ones_value, (_ptr), sizeof(*(_ptr))))

/* The octets object is a struct holding pointer and length */
typedef struct of_octets_s {
    uint8_t *data;
    int bytes;
} of_octets_t;

/* Macro to convert an octet object to a pointer; currently trivial */
#define OF_OCTETS_POINTER_GET(octet_ptr) ((octet_ptr)->data)
#define OF_OCTETS_POINTER_SET(octet_ptr, ptr) (octet_ptr)->data = (ptr)
#define OF_OCTETS_BYTES_GET(octet_ptr) ((octet_ptr)->bytes)
#define OF_OCTETS_BYTES_SET(octet_ptr, bytes) (octet_ptr)->bytes = (bytes)

/* Currently these are categorized as scalars */
typedef char of_port_name_t[OF_MAX_PORT_NAME_LEN];
typedef char of_table_name_t[OF_MAX_TABLE_NAME_LEN];
typedef char of_desc_str_t[OF_DESC_STR_LEN];
typedef char of_serial_num_t[OF_SERIAL_NUM_LEN];
typedef char of_str64_t[64];

typedef struct of_bitmap_128_s {
    uint64_t hi;
    uint64_t lo;
} of_bitmap_128_t;

typedef struct of_checksum_128_s {
    uint64_t hi;
    uint64_t lo;
} of_checksum_128_t;

/* These are types which change across versions.  */
typedef uint32_t of_port_no_t;
typedef uint16_t of_fm_cmd_t;
typedef uint64_t of_wc_bmap_t;
typedef uint64_t of_match_bmap_t;

#define MEMMOVE(dest, src, bytes) memmove(dest, src, bytes)
#define MEMSET(dest, val, bytes) memset(dest, val, bytes)
#define MEMCPY(dest, src, bytes) memcpy(dest, src, bytes)
#define MEMCMP(a, b, bytes) memcmp(a, b, bytes)
#define MALLOC(bytes) malloc(bytes)
#define FREE(ptr) free(ptr)

/** Try an operation and return on failure. */
#define OF_TRY(op) do {                                                      \
        int _rv;                                                             \
        if ((_rv = (op)) < 0) {                                              \
            LOCI_LOG_ERROR("ERROR %d at %s:%d\n", _rv, __FILE__, __LINE__); \
            return _rv;                                                      \
        }                                                                    \
    } while (0)

/* The extent of an OF match object is determined by its length field, but
 * aligned to 8 bytes
 */

#define OF_MATCH_BYTES(length) (((length) + 7) & 0xfff8)

#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
#define U16_NTOH(val) (val)
#define U32_NTOH(val) (val)
#define U64_NTOH(val) (val)
#define IPV6_NTOH(dst, src) /* NOTE different syntax; currently no-op */
#define U16_HTON(val) (val)
#define U32_HTON(val) (val)
#define U64_HTON(val) (val)
#define IPV6_HTON(dst, src) /* NOTE different syntax; currently no-op */
#else /* Little Endian */
#define U16_NTOH(val) (((val) >> 8) | (((val) & 0xff) << 8))
#define U32_NTOH(val) ((((val) & 0xff000000) >> 24) |                   \
                       (((val) & 0x00ff0000) >>  8) |                   \
                       (((val) & 0x0000ff00) <<  8) |                   \
                       (((val) & 0x000000ff) << 24))
#define U64_NTOH(val) ((((val) & 0xff00000000000000LL) >> 56) |         \
                       (((val) & 0x00ff000000000000LL) >> 40) |         \
                       (((val) & 0x0000ff0000000000LL) >> 24) |         \
                       (((val) & 0x000000ff00000000LL) >>  8) |         \
                       (((val) & 0x00000000ff000000LL) <<  8) |         \
                       (((val) & 0x0000000000ff0000LL) << 24) |         \
                       (((val) & 0x000000000000ff00LL) << 40) |         \
                       (((val) & 0x00000000000000ffLL) << 56))
#define IPV6_NTOH(dst, src) /* NOTE different syntax; currently no-op */
#define U16_HTON(val) U16_NTOH(val)
#define U32_HTON(val) U32_NTOH(val)
#define U64_HTON(val) U64_NTOH(val)
#define IPV6_HTON(dst, src) /* NOTE different syntax; currently no-op */
#endif


/**
 * Enumeration of OpenFlow objects
 *
 * We enumerate the OpenFlow objects used internally.  Note that some
 * message types are determined both by an outer type (message type like
 * stats_request) and an inner type (port stats).  These are different
 * messages in ofC.
 *
 * These values are for internal use only.  They will change with
 * different versions of ofC.
 */

typedef enum of_object_id_e {
    /* Root object type */
    OF_OBJECT_INVALID = -1, /* "invalid" return value for mappings */
    OF_OBJECT = 0, /* Generic, untyped object */

    /* OpenFlow message objects */
    OF_AGGREGATE_STATS_REPLY = 1,
    OF_AGGREGATE_STATS_REQUEST = 2,
    OF_ASYNC_CONFIG_FAILED_ERROR_MSG = 3,
    OF_ASYNC_GET_REPLY = 4,
    OF_ASYNC_GET_REQUEST = 5,
    OF_ASYNC_SET = 6,
    OF_BAD_ACTION_ERROR_MSG = 7,
    OF_BAD_INSTRUCTION_ERROR_MSG = 8,
    OF_BAD_MATCH_ERROR_MSG = 9,
    OF_BAD_PROPERTY_ERROR_MSG = 10,
    OF_BAD_REQUEST_ERROR_MSG = 11,
    OF_BARRIER_REPLY = 12,
    OF_BARRIER_REQUEST = 13,
    OF_BSN_ARP_IDLE = 14,
    OF_BSN_BW_CLEAR_DATA_REPLY = 15,
    OF_BSN_BW_CLEAR_DATA_REQUEST = 16,
    OF_BSN_BW_ENABLE_GET_REPLY = 17,
    OF_BSN_BW_ENABLE_GET_REQUEST = 18,
    OF_BSN_BW_ENABLE_SET_REPLY = 19,
    OF_BSN_BW_ENABLE_SET_REQUEST = 20,
    OF_BSN_CONTROLLER_CONNECTIONS_REPLY = 21,
    OF_BSN_CONTROLLER_CONNECTIONS_REQUEST = 22,
    OF_BSN_DEBUG_COUNTER_DESC_STATS_REPLY = 23,
    OF_BSN_DEBUG_COUNTER_DESC_STATS_REQUEST = 24,
    OF_BSN_DEBUG_COUNTER_STATS_REPLY = 25,
    OF_BSN_DEBUG_COUNTER_STATS_REQUEST = 26,
    OF_BSN_FLOW_CHECKSUM_BUCKET_STATS_REPLY = 27,
    OF_BSN_FLOW_CHECKSUM_BUCKET_STATS_REQUEST = 28,
    OF_BSN_FLOW_IDLE = 29,
    OF_BSN_FLOW_IDLE_ENABLE_GET_REPLY = 30,
    OF_BSN_FLOW_IDLE_ENABLE_GET_REQUEST = 31,
    OF_BSN_FLOW_IDLE_ENABLE_SET_REPLY = 32,
    OF_BSN_FLOW_IDLE_ENABLE_SET_REQUEST = 33,
    OF_BSN_GENERIC_STATS_REPLY = 34,
    OF_BSN_GENERIC_STATS_REQUEST = 35,
    OF_BSN_GENTABLE_BUCKET_STATS_REPLY = 36,
    OF_BSN_GENTABLE_BUCKET_STATS_REQUEST = 37,
    OF_BSN_GENTABLE_CLEAR_REPLY = 38,
    OF_BSN_GENTABLE_CLEAR_REQUEST = 39,
    OF_BSN_GENTABLE_DESC_STATS_REPLY = 40,
    OF_BSN_GENTABLE_DESC_STATS_REQUEST = 41,
    OF_BSN_GENTABLE_ENTRY_ADD = 42,
    OF_BSN_GENTABLE_ENTRY_DELETE = 43,
    OF_BSN_GENTABLE_ENTRY_DESC_STATS_REPLY = 44,
    OF_BSN_GENTABLE_ENTRY_DESC_STATS_REQUEST = 45,
    OF_BSN_GENTABLE_ENTRY_STATS_REPLY = 46,
    OF_BSN_GENTABLE_ENTRY_STATS_REQUEST = 47,
    OF_BSN_GENTABLE_SET_BUCKETS_SIZE = 48,
    OF_BSN_GENTABLE_STATS_REPLY = 49,
    OF_BSN_GENTABLE_STATS_REQUEST = 50,
    OF_BSN_GET_INTERFACES_REPLY = 51,
    OF_BSN_GET_INTERFACES_REQUEST = 52,
    OF_BSN_GET_IP_MASK_REPLY = 53,
    OF_BSN_GET_IP_MASK_REQUEST = 54,
    OF_BSN_GET_L2_TABLE_REPLY = 55,
    OF_BSN_GET_L2_TABLE_REQUEST = 56,
    OF_BSN_GET_MIRRORING_REPLY = 57,
    OF_BSN_GET_MIRRORING_REQUEST = 58,
    OF_BSN_GET_SWITCH_PIPELINE_REPLY = 59,
    OF_BSN_GET_SWITCH_PIPELINE_REQUEST = 60,
    OF_BSN_HEADER = 61,
    OF_BSN_HYBRID_GET_REPLY = 62,
    OF_BSN_HYBRID_GET_REQUEST = 63,
    OF_BSN_IMAGE_DESC_STATS_REPLY = 64,
    OF_BSN_IMAGE_DESC_STATS_REQUEST = 65,
    OF_BSN_LACP_CONVERGENCE_NOTIF = 66,
    OF_BSN_LACP_STATS_REPLY = 67,
    OF_BSN_LACP_STATS_REQUEST = 68,
    OF_BSN_LOG = 69,
    OF_BSN_LUA_COMMAND_REPLY = 70,
    OF_BSN_LUA_COMMAND_REQUEST = 71,
    OF_BSN_LUA_NOTIFICATION = 72,
    OF_BSN_LUA_UPLOAD = 73,
    OF_BSN_PDU_RX_REPLY = 74,
    OF_BSN_PDU_RX_REQUEST = 75,
    OF_BSN_PDU_RX_TIMEOUT = 76,
    OF_BSN_PDU_TX_REPLY = 77,
    OF_BSN_PDU_TX_REQUEST = 78,
    OF_BSN_PORT_COUNTER_STATS_REPLY = 79,
    OF_BSN_PORT_COUNTER_STATS_REQUEST = 80,
    OF_BSN_ROLE_STATUS = 81,
    OF_BSN_SET_AUX_CXNS_REPLY = 82,
    OF_BSN_SET_AUX_CXNS_REQUEST = 83,
    OF_BSN_SET_IP_MASK = 84,
    OF_BSN_SET_L2_TABLE_REPLY = 85,
    OF_BSN_SET_L2_TABLE_REQUEST = 86,
    OF_BSN_SET_LACP_REPLY = 87,
    OF_BSN_SET_LACP_REQUEST = 88,
    OF_BSN_SET_MIRRORING = 89,
    OF_BSN_SET_PKTIN_SUPPRESSION_REPLY = 90,
    OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST = 91,
    OF_BSN_SET_SWITCH_PIPELINE_REPLY = 92,
    OF_BSN_SET_SWITCH_PIPELINE_REQUEST = 93,
    OF_BSN_SHELL_COMMAND = 94,
    OF_BSN_SHELL_OUTPUT = 95,
    OF_BSN_SHELL_STATUS = 96,
    OF_BSN_STATS_REPLY = 97,
    OF_BSN_STATS_REQUEST = 98,
    OF_BSN_SWITCH_PIPELINE_STATS_REPLY = 99,
    OF_BSN_SWITCH_PIPELINE_STATS_REQUEST = 100,
    OF_BSN_TABLE_CHECKSUM_STATS_REPLY = 101,
    OF_BSN_TABLE_CHECKSUM_STATS_REQUEST = 102,
    OF_BSN_TABLE_SET_BUCKETS_SIZE = 103,
    OF_BSN_TIME_REPLY = 104,
    OF_BSN_TIME_REQUEST = 105,
    OF_BSN_VIRTUAL_PORT_CREATE_REPLY = 106,
    OF_BSN_VIRTUAL_PORT_CREATE_REQUEST = 107,
    OF_BSN_VIRTUAL_PORT_REMOVE_REPLY = 108,
    OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST = 109,
    OF_BSN_VLAN_COUNTER_STATS_REPLY = 110,
    OF_BSN_VLAN_COUNTER_STATS_REQUEST = 111,
    OF_BSN_VRF_COUNTER_STATS_REPLY = 112,
    OF_BSN_VRF_COUNTER_STATS_REQUEST = 113,
    OF_BUNDLE_ADD_MSG = 114,
    OF_BUNDLE_CTRL_MSG = 115,
    OF_BUNDLE_FAILED_ERROR_MSG = 116,
    OF_DESC_STATS_REPLY = 117,
    OF_DESC_STATS_REQUEST = 118,
    OF_ECHO_REPLY = 119,
    OF_ECHO_REQUEST = 120,
    OF_ERROR_MSG = 121,
    OF_EXPERIMENTER = 122,
    OF_EXPERIMENTER_ERROR_MSG = 123,
    OF_EXPERIMENTER_STATS_REPLY = 124,
    OF_EXPERIMENTER_STATS_REQUEST = 125,
    OF_FEATURES_REPLY = 126,
    OF_FEATURES_REQUEST = 127,
    OF_FLOW_ADD = 128,
    OF_FLOW_DELETE = 129,
    OF_FLOW_DELETE_STRICT = 130,
    OF_FLOW_MOD = 131,
    OF_FLOW_MOD_FAILED_ERROR_MSG = 132,
    OF_FLOW_MODIFY = 133,
    OF_FLOW_MODIFY_STRICT = 134,
    OF_FLOW_MONITOR_FAILED_ERROR_MSG = 135,
    OF_FLOW_REMOVED = 136,
    OF_FLOW_STATS_REPLY = 137,
    OF_FLOW_STATS_REQUEST = 138,
    OF_GET_CONFIG_REPLY = 139,
    OF_GET_CONFIG_REQUEST = 140,
    OF_GROUP_ADD = 141,
    OF_GROUP_DELETE = 142,
    OF_GROUP_DESC_STATS_REPLY = 143,
    OF_GROUP_DESC_STATS_REQUEST = 144,
    OF_GROUP_FEATURES_STATS_REPLY = 145,
    OF_GROUP_FEATURES_STATS_REQUEST = 146,
    OF_GROUP_MOD = 147,
    OF_GROUP_MOD_FAILED_ERROR_MSG = 148,
    OF_GROUP_MODIFY = 149,
    OF_GROUP_STATS_REPLY = 150,
    OF_GROUP_STATS_REQUEST = 151,
    OF_HEADER = 152,
    OF_HELLO = 153,
    OF_HELLO_FAILED_ERROR_MSG = 154,
    OF_METER_CONFIG_STATS_REPLY = 155,
    OF_METER_CONFIG_STATS_REQUEST = 156,
    OF_METER_FEATURES_STATS_REPLY = 157,
    OF_METER_FEATURES_STATS_REQUEST = 158,
    OF_METER_MOD = 159,
    OF_METER_MOD_FAILED_ERROR_MSG = 160,
    OF_METER_STATS_REPLY = 161,
    OF_METER_STATS_REQUEST = 162,
    OF_NICIRA_CONTROLLER_ROLE_REPLY = 163,
    OF_NICIRA_CONTROLLER_ROLE_REQUEST = 164,
    OF_NICIRA_HEADER = 165,
    OF_PACKET_IN = 166,
    OF_PACKET_OUT = 167,
    OF_PORT_DESC_STATS_REPLY = 168,
    OF_PORT_DESC_STATS_REQUEST = 169,
    OF_PORT_MOD = 170,
    OF_PORT_MOD_FAILED_ERROR_MSG = 171,
    OF_PORT_STATS_REPLY = 172,
    OF_PORT_STATS_REQUEST = 173,
    OF_PORT_STATUS = 174,
    OF_QUEUE_DESC_STATS_REPLY = 175,
    OF_QUEUE_DESC_STATS_REQUEST = 176,
    OF_QUEUE_GET_CONFIG_REPLY = 177,
    OF_QUEUE_GET_CONFIG_REQUEST = 178,
    OF_QUEUE_OP_FAILED_ERROR_MSG = 179,
    OF_QUEUE_STATS_REPLY = 180,
    OF_QUEUE_STATS_REQUEST = 181,
    OF_REQUESTFORWARD = 182,
    OF_ROLE_REPLY = 183,
    OF_ROLE_REQUEST = 184,
    OF_ROLE_REQUEST_FAILED_ERROR_MSG = 185,
    OF_ROLE_STATUS = 186,
    OF_SET_CONFIG = 187,
    OF_STATS_REPLY = 188,
    OF_STATS_REQUEST = 189,
    OF_SWITCH_CONFIG_FAILED_ERROR_MSG = 190,
    OF_TABLE_DESC_STATS_REPLY = 191,
    OF_TABLE_DESC_STATS_REQUEST = 192,
    OF_TABLE_FEATURES_FAILED_ERROR_MSG = 193,
    OF_TABLE_FEATURES_STATS_REPLY = 194,
    OF_TABLE_FEATURES_STATS_REQUEST = 195,
    OF_TABLE_MOD = 196,
    OF_TABLE_MOD_FAILED_ERROR_MSG = 197,
    OF_TABLE_STATS_REPLY = 198,
    OF_TABLE_STATS_REQUEST = 199,
    OF_TABLE_STATUS = 200,

    /* Non-message objects */
    OF_ACTION = 201,
    OF_ACTION_BSN = 202,
    OF_ACTION_BSN_CHECKSUM = 203,
    OF_ACTION_BSN_GENTABLE = 204,
    OF_ACTION_BSN_MIRROR = 205,
    OF_ACTION_BSN_SET_TUNNEL_DST = 206,
    OF_ACTION_COPY_TTL_IN = 207,
    OF_ACTION_COPY_TTL_OUT = 208,
    OF_ACTION_DEC_MPLS_TTL = 209,
    OF_ACTION_DEC_NW_TTL = 210,
    OF_ACTION_ENQUEUE = 211,
    OF_ACTION_EXPERIMENTER = 212,
    OF_ACTION_GROUP = 213,
    OF_ACTION_ID = 214,
    OF_ACTION_ID_BSN = 215,
    OF_ACTION_ID_BSN_CHECKSUM = 216,
    OF_ACTION_ID_BSN_GENTABLE = 217,
    OF_ACTION_ID_BSN_MIRROR = 218,
    OF_ACTION_ID_BSN_SET_TUNNEL_DST = 219,
    OF_ACTION_ID_COPY_TTL_IN = 220,
    OF_ACTION_ID_COPY_TTL_OUT = 221,
    OF_ACTION_ID_DEC_MPLS_TTL = 222,
    OF_ACTION_ID_DEC_NW_TTL = 223,
    OF_ACTION_ID_EXPERIMENTER = 224,
    OF_ACTION_ID_GROUP = 225,
    OF_ACTION_ID_NICIRA = 226,
    OF_ACTION_ID_NICIRA_DEC_TTL = 227,
    OF_ACTION_ID_OUTPUT = 228,
    OF_ACTION_ID_POP_MPLS = 229,
    OF_ACTION_ID_POP_PBB = 230,
    OF_ACTION_ID_POP_VLAN = 231,
    OF_ACTION_ID_PUSH_MPLS = 232,
    OF_ACTION_ID_PUSH_PBB = 233,
    OF_ACTION_ID_PUSH_VLAN = 234,
    OF_ACTION_ID_SET_FIELD = 235,
    OF_ACTION_ID_SET_MPLS_TTL = 236,
    OF_ACTION_ID_SET_NW_TTL = 237,
    OF_ACTION_ID_SET_QUEUE = 238,
    OF_ACTION_NICIRA = 239,
    OF_ACTION_NICIRA_DEC_TTL = 240,
    OF_ACTION_OUTPUT = 241,
    OF_ACTION_POP_MPLS = 242,
    OF_ACTION_POP_PBB = 243,
    OF_ACTION_POP_VLAN = 244,
    OF_ACTION_PUSH_MPLS = 245,
    OF_ACTION_PUSH_PBB = 246,
    OF_ACTION_PUSH_VLAN = 247,
    OF_ACTION_SET_DL_DST = 248,
    OF_ACTION_SET_DL_SRC = 249,
    OF_ACTION_SET_FIELD = 250,
    OF_ACTION_SET_MPLS_LABEL = 251,
    OF_ACTION_SET_MPLS_TC = 252,
    OF_ACTION_SET_MPLS_TTL = 253,
    OF_ACTION_SET_NW_DST = 254,
    OF_ACTION_SET_NW_ECN = 255,
    OF_ACTION_SET_NW_SRC = 256,
    OF_ACTION_SET_NW_TOS = 257,
    OF_ACTION_SET_NW_TTL = 258,
    OF_ACTION_SET_QUEUE = 259,
    OF_ACTION_SET_TP_DST = 260,
    OF_ACTION_SET_TP_SRC = 261,
    OF_ACTION_SET_VLAN_PCP = 262,
    OF_ACTION_SET_VLAN_VID = 263,
    OF_ACTION_STRIP_VLAN = 264,
    OF_ASYNC_CONFIG_PROP = 265,
    OF_ASYNC_CONFIG_PROP_EXPERIMENTER_MASTER = 266,
    OF_ASYNC_CONFIG_PROP_EXPERIMENTER_SLAVE = 267,
    OF_ASYNC_CONFIG_PROP_FLOW_REMOVED_MASTER = 268,
    OF_ASYNC_CONFIG_PROP_FLOW_REMOVED_SLAVE = 269,
    OF_ASYNC_CONFIG_PROP_PACKET_IN_MASTER = 270,
    OF_ASYNC_CONFIG_PROP_PACKET_IN_SLAVE = 271,
    OF_ASYNC_CONFIG_PROP_PORT_STATUS_MASTER = 272,
    OF_ASYNC_CONFIG_PROP_PORT_STATUS_SLAVE = 273,
    OF_ASYNC_CONFIG_PROP_REQUESTFORWARD_MASTER = 274,
    OF_ASYNC_CONFIG_PROP_REQUESTFORWARD_SLAVE = 275,
    OF_ASYNC_CONFIG_PROP_ROLE_STATUS_MASTER = 276,
    OF_ASYNC_CONFIG_PROP_ROLE_STATUS_SLAVE = 277,
    OF_ASYNC_CONFIG_PROP_TABLE_STATUS_MASTER = 278,
    OF_ASYNC_CONFIG_PROP_TABLE_STATUS_SLAVE = 279,
    OF_BSN_CONTROLLER_CONNECTION = 280,
    OF_BSN_DEBUG_COUNTER_DESC_STATS_ENTRY = 281,
    OF_BSN_DEBUG_COUNTER_STATS_ENTRY = 282,
    OF_BSN_FLOW_CHECKSUM_BUCKET_STATS_ENTRY = 283,
    OF_BSN_GENERIC_STATS_ENTRY = 284,
    OF_BSN_GENTABLE_BUCKET_STATS_ENTRY = 285,
    OF_BSN_GENTABLE_DESC_STATS_ENTRY = 286,
    OF_BSN_GENTABLE_ENTRY_DESC_STATS_ENTRY = 287,
    OF_BSN_GENTABLE_ENTRY_STATS_ENTRY = 288,
    OF_BSN_GENTABLE_STATS_ENTRY = 289,
    OF_BSN_INTERFACE = 290,
    OF_BSN_LACP_STATS_ENTRY = 291,
    OF_BSN_PORT_COUNTER_STATS_ENTRY = 292,
    OF_BSN_SWITCH_PIPELINE_STATS_ENTRY = 293,
    OF_BSN_TABLE_CHECKSUM_STATS_ENTRY = 294,
    OF_BSN_TLV = 295,
    OF_BSN_TLV_ACTOR_KEY = 296,
    OF_BSN_TLV_ACTOR_PORT_NUM = 297,
    OF_BSN_TLV_ACTOR_PORT_PRIORITY = 298,
    OF_BSN_TLV_ACTOR_STATE = 299,
    OF_BSN_TLV_ACTOR_SYSTEM_MAC = 300,
    OF_BSN_TLV_ACTOR_SYSTEM_PRIORITY = 301,
    OF_BSN_TLV_BROADCAST_QUERY_TIMEOUT = 302,
    OF_BSN_TLV_BUCKET = 303,
    OF_BSN_TLV_CIRCUIT_ID = 304,
    OF_BSN_TLV_CONVERGENCE_STATUS = 305,
    OF_BSN_TLV_CRC_ENABLED = 306,
    OF_BSN_TLV_DATA = 307,
    OF_BSN_TLV_ETH_DST = 308,
    OF_BSN_TLV_ETH_SRC = 309,
    OF_BSN_TLV_EXTERNAL_GATEWAY_IP = 310,
    OF_BSN_TLV_EXTERNAL_GATEWAY_MAC = 311,
    OF_BSN_TLV_EXTERNAL_IP = 312,
    OF_BSN_TLV_EXTERNAL_MAC = 313,
    OF_BSN_TLV_EXTERNAL_NETMASK = 314,
    OF_BSN_TLV_HEADER_SIZE = 315,
    OF_BSN_TLV_ICMP_CODE = 316,
    OF_BSN_TLV_ICMP_ID = 317,
    OF_BSN_TLV_ICMP_TYPE = 318,
    OF_BSN_TLV_IDLE_NOTIFICATION = 319,
    OF_BSN_TLV_IDLE_TIME = 320,
    OF_BSN_TLV_IDLE_TIMEOUT = 321,
    OF_BSN_TLV_INTERNAL_GATEWAY_MAC = 322,
    OF_BSN_TLV_INTERNAL_MAC = 323,
    OF_BSN_TLV_INTERVAL = 324,
    OF_BSN_TLV_IP_PROTO = 325,
    OF_BSN_TLV_IPV4 = 326,
    OF_BSN_TLV_IPV4_DST = 327,
    OF_BSN_TLV_IPV4_NETMASK = 328,
    OF_BSN_TLV_IPV4_SRC = 329,
    OF_BSN_TLV_MAC = 330,
    OF_BSN_TLV_MAC_MASK = 331,
    OF_BSN_TLV_MISS_PACKETS = 332,
    OF_BSN_TLV_MPLS_CONTROL_WORD = 333,
    OF_BSN_TLV_MPLS_LABEL = 334,
    OF_BSN_TLV_MPLS_SEQUENCED = 335,
    OF_BSN_TLV_NAME = 336,
    OF_BSN_TLV_PARTNER_KEY = 337,
    OF_BSN_TLV_PARTNER_PORT_NUM = 338,
    OF_BSN_TLV_PARTNER_PORT_PRIORITY = 339,
    OF_BSN_TLV_PARTNER_STATE = 340,
    OF_BSN_TLV_PARTNER_SYSTEM_MAC = 341,
    OF_BSN_TLV_PARTNER_SYSTEM_PRIORITY = 342,
    OF_BSN_TLV_PORT = 343,
    OF_BSN_TLV_PRIORITY = 344,
    OF_BSN_TLV_QUEUE_ID = 345,
    OF_BSN_TLV_QUEUE_WEIGHT = 346,
    OF_BSN_TLV_REFERENCE = 347,
    OF_BSN_TLV_REPLY_PACKETS = 348,
    OF_BSN_TLV_REQUEST_PACKETS = 349,
    OF_BSN_TLV_RX_BYTES = 350,
    OF_BSN_TLV_RX_PACKETS = 351,
    OF_BSN_TLV_SAMPLING_RATE = 352,
    OF_BSN_TLV_SUB_AGENT_ID = 353,
    OF_BSN_TLV_TCP_DST = 354,
    OF_BSN_TLV_TCP_SRC = 355,
    OF_BSN_TLV_TX_BYTES = 356,
    OF_BSN_TLV_TX_PACKETS = 357,
    OF_BSN_TLV_UDF_ANCHOR = 358,
    OF_BSN_TLV_UDF_ID = 359,
    OF_BSN_TLV_UDF_LENGTH = 360,
    OF_BSN_TLV_UDF_OFFSET = 361,
    OF_BSN_TLV_UDP_DST = 362,
    OF_BSN_TLV_UDP_SRC = 363,
    OF_BSN_TLV_UNICAST_QUERY_TIMEOUT = 364,
    OF_BSN_TLV_VLAN_PCP = 365,
    OF_BSN_TLV_VLAN_VID = 366,
    OF_BSN_TLV_VRF = 367,
    OF_BSN_VLAN_COUNTER_STATS_ENTRY = 368,
    OF_BSN_VPORT = 369,
    OF_BSN_VPORT_L2GRE = 370,
    OF_BSN_VPORT_Q_IN_Q = 371,
    OF_BSN_VRF_COUNTER_STATS_ENTRY = 372,
    OF_BUCKET = 373,
    OF_BUCKET_COUNTER = 374,
    OF_BUNDLE_PROP = 375,
    OF_BUNDLE_PROP_EXPERIMENTER = 376,
    OF_FLOW_STATS_ENTRY = 377,
    OF_GROUP_DESC_STATS_ENTRY = 378,
    OF_GROUP_STATS_ENTRY = 379,
    OF_HELLO_ELEM = 380,
    OF_HELLO_ELEM_VERSIONBITMAP = 381,
    OF_INSTRUCTION = 382,
    OF_INSTRUCTION_APPLY_ACTIONS = 383,
    OF_INSTRUCTION_BSN = 384,
    OF_INSTRUCTION_BSN_ARP_OFFLOAD = 385,
    OF_INSTRUCTION_BSN_AUTO_NEGOTIATION = 386,
    OF_INSTRUCTION_BSN_DENY = 387,
    OF_INSTRUCTION_BSN_DHCP_OFFLOAD = 388,
    OF_INSTRUCTION_BSN_DISABLE_SPLIT_HORIZON_CHECK = 389,
    OF_INSTRUCTION_BSN_DISABLE_SRC_MAC_CHECK = 390,
    OF_INSTRUCTION_BSN_DISABLE_VLAN_COUNTERS = 391,
    OF_INSTRUCTION_BSN_INTERNAL_PRIORITY = 392,
    OF_INSTRUCTION_BSN_PACKET_OF_DEATH = 393,
    OF_INSTRUCTION_BSN_PERMIT = 394,
    OF_INSTRUCTION_BSN_PRIORITIZE_PDUS = 395,
    OF_INSTRUCTION_BSN_REQUIRE_VLAN_XLATE = 396,
    OF_INSTRUCTION_BSN_SPAN_DESTINATION = 397,
    OF_INSTRUCTION_CLEAR_ACTIONS = 398,
    OF_INSTRUCTION_EXPERIMENTER = 399,
    OF_INSTRUCTION_GOTO_TABLE = 400,
    OF_INSTRUCTION_ID = 401,
    OF_INSTRUCTION_ID_APPLY_ACTIONS = 402,
    OF_INSTRUCTION_ID_BSN = 403,
    OF_INSTRUCTION_ID_BSN_ARP_OFFLOAD = 404,
    OF_INSTRUCTION_ID_BSN_AUTO_NEGOTIATION = 405,
    OF_INSTRUCTION_ID_BSN_DENY = 406,
    OF_INSTRUCTION_ID_BSN_DHCP_OFFLOAD = 407,
    OF_INSTRUCTION_ID_BSN_DISABLE_SPLIT_HORIZON_CHECK = 408,
    OF_INSTRUCTION_ID_BSN_DISABLE_SRC_MAC_CHECK = 409,
    OF_INSTRUCTION_ID_BSN_DISABLE_VLAN_COUNTERS = 410,
    OF_INSTRUCTION_ID_BSN_INTERNAL_PRIORITY = 411,
    OF_INSTRUCTION_ID_BSN_PACKET_OF_DEATH = 412,
    OF_INSTRUCTION_ID_BSN_PERMIT = 413,
    OF_INSTRUCTION_ID_BSN_PRIORITIZE_PDUS = 414,
    OF_INSTRUCTION_ID_BSN_REQUIRE_VLAN_XLATE = 415,
    OF_INSTRUCTION_ID_BSN_SPAN_DESTINATION = 416,
    OF_INSTRUCTION_ID_CLEAR_ACTIONS = 417,
    OF_INSTRUCTION_ID_EXPERIMENTER = 418,
    OF_INSTRUCTION_ID_GOTO_TABLE = 419,
    OF_INSTRUCTION_ID_METER = 420,
    OF_INSTRUCTION_ID_WRITE_ACTIONS = 421,
    OF_INSTRUCTION_ID_WRITE_METADATA = 422,
    OF_INSTRUCTION_METER = 423,
    OF_INSTRUCTION_WRITE_ACTIONS = 424,
    OF_INSTRUCTION_WRITE_METADATA = 425,
    OF_MATCH_V1 = 426,
    OF_MATCH_V2 = 427,
    OF_MATCH_V3 = 428,
    OF_METER_BAND = 429,
    OF_METER_BAND_DROP = 430,
    OF_METER_BAND_DSCP_REMARK = 431,
    OF_METER_BAND_EXPERIMENTER = 432,
    OF_METER_BAND_STATS = 433,
    OF_METER_CONFIG = 434,
    OF_METER_FEATURES = 435,
    OF_METER_STATS = 436,
    OF_OXM = 437,
    OF_OXM_ARP_OP = 438,
    OF_OXM_ARP_OP_MASKED = 439,
    OF_OXM_ARP_SHA = 440,
    OF_OXM_ARP_SHA_MASKED = 441,
    OF_OXM_ARP_SPA = 442,
    OF_OXM_ARP_SPA_MASKED = 443,
    OF_OXM_ARP_THA = 444,
    OF_OXM_ARP_THA_MASKED = 445,
    OF_OXM_ARP_TPA = 446,
    OF_OXM_ARP_TPA_MASKED = 447,
    OF_OXM_BSN_EGR_PORT_GROUP_ID = 448,
    OF_OXM_BSN_EGR_PORT_GROUP_ID_MASKED = 449,
    OF_OXM_BSN_GLOBAL_VRF_ALLOWED = 450,
    OF_OXM_BSN_GLOBAL_VRF_ALLOWED_MASKED = 451,
    OF_OXM_BSN_IN_PORTS_128 = 452,
    OF_OXM_BSN_IN_PORTS_128_MASKED = 453,
    OF_OXM_BSN_IN_PORTS_512 = 454,
    OF_OXM_BSN_IN_PORTS_512_MASKED = 455,
    OF_OXM_BSN_INGRESS_PORT_GROUP_ID = 456,
    OF_OXM_BSN_INGRESS_PORT_GROUP_ID_MASKED = 457,
    OF_OXM_BSN_L2_CACHE_HIT = 458,
    OF_OXM_BSN_L2_CACHE_HIT_MASKED = 459,
    OF_OXM_BSN_L3_DST_CLASS_ID = 460,
    OF_OXM_BSN_L3_DST_CLASS_ID_MASKED = 461,
    OF_OXM_BSN_L3_INTERFACE_CLASS_ID = 462,
    OF_OXM_BSN_L3_INTERFACE_CLASS_ID_MASKED = 463,
    OF_OXM_BSN_L3_SRC_CLASS_ID = 464,
    OF_OXM_BSN_L3_SRC_CLASS_ID_MASKED = 465,
    OF_OXM_BSN_LAG_ID = 466,
    OF_OXM_BSN_LAG_ID_MASKED = 467,
    OF_OXM_BSN_TCP_FLAGS = 468,
    OF_OXM_BSN_TCP_FLAGS_MASKED = 469,
    OF_OXM_BSN_UDF0 = 470,
    OF_OXM_BSN_UDF0_MASKED = 471,
    OF_OXM_BSN_UDF1 = 472,
    OF_OXM_BSN_UDF1_MASKED = 473,
    OF_OXM_BSN_UDF2 = 474,
    OF_OXM_BSN_UDF2_MASKED = 475,
    OF_OXM_BSN_UDF3 = 476,
    OF_OXM_BSN_UDF3_MASKED = 477,
    OF_OXM_BSN_UDF4 = 478,
    OF_OXM_BSN_UDF4_MASKED = 479,
    OF_OXM_BSN_UDF5 = 480,
    OF_OXM_BSN_UDF5_MASKED = 481,
    OF_OXM_BSN_UDF6 = 482,
    OF_OXM_BSN_UDF6_MASKED = 483,
    OF_OXM_BSN_UDF7 = 484,
    OF_OXM_BSN_UDF7_MASKED = 485,
    OF_OXM_BSN_VLAN_XLATE_PORT_GROUP_ID = 486,
    OF_OXM_BSN_VLAN_XLATE_PORT_GROUP_ID_MASKED = 487,
    OF_OXM_BSN_VRF = 488,
    OF_OXM_BSN_VRF_MASKED = 489,
    OF_OXM_ETH_DST = 490,
    OF_OXM_ETH_DST_MASKED = 491,
    OF_OXM_ETH_SRC = 492,
    OF_OXM_ETH_SRC_MASKED = 493,
    OF_OXM_ETH_TYPE = 494,
    OF_OXM_ETH_TYPE_MASKED = 495,
    OF_OXM_ICMPV4_CODE = 496,
    OF_OXM_ICMPV4_CODE_MASKED = 497,
    OF_OXM_ICMPV4_TYPE = 498,
    OF_OXM_ICMPV4_TYPE_MASKED = 499,
    OF_OXM_ICMPV6_CODE = 500,
    OF_OXM_ICMPV6_CODE_MASKED = 501,
    OF_OXM_ICMPV6_TYPE = 502,
    OF_OXM_ICMPV6_TYPE_MASKED = 503,
    OF_OXM_IN_PHY_PORT = 504,
    OF_OXM_IN_PHY_PORT_MASKED = 505,
    OF_OXM_IN_PORT = 506,
    OF_OXM_IN_PORT_MASKED = 507,
    OF_OXM_IP_DSCP = 508,
    OF_OXM_IP_DSCP_MASKED = 509,
    OF_OXM_IP_ECN = 510,
    OF_OXM_IP_ECN_MASKED = 511,
    OF_OXM_IP_PROTO = 512,
    OF_OXM_IP_PROTO_MASKED = 513,
    OF_OXM_IPV4_DST = 514,
    OF_OXM_IPV4_DST_MASKED = 515,
    OF_OXM_IPV4_SRC = 516,
    OF_OXM_IPV4_SRC_MASKED = 517,
    OF_OXM_IPV6_DST = 518,
    OF_OXM_IPV6_DST_MASKED = 519,
    OF_OXM_IPV6_EXTHDR = 520,
    OF_OXM_IPV6_EXTHDR_MASKED = 521,
    OF_OXM_IPV6_FLABEL = 522,
    OF_OXM_IPV6_FLABEL_MASKED = 523,
    OF_OXM_IPV6_ND_SLL = 524,
    OF_OXM_IPV6_ND_SLL_MASKED = 525,
    OF_OXM_IPV6_ND_TARGET = 526,
    OF_OXM_IPV6_ND_TARGET_MASKED = 527,
    OF_OXM_IPV6_ND_TLL = 528,
    OF_OXM_IPV6_ND_TLL_MASKED = 529,
    OF_OXM_IPV6_SRC = 530,
    OF_OXM_IPV6_SRC_MASKED = 531,
    OF_OXM_METADATA = 532,
    OF_OXM_METADATA_MASKED = 533,
    OF_OXM_MPLS_BOS = 534,
    OF_OXM_MPLS_BOS_MASKED = 535,
    OF_OXM_MPLS_LABEL = 536,
    OF_OXM_MPLS_LABEL_MASKED = 537,
    OF_OXM_MPLS_TC = 538,
    OF_OXM_MPLS_TC_MASKED = 539,
    OF_OXM_PBB_UCA = 540,
    OF_OXM_PBB_UCA_MASKED = 541,
    OF_OXM_SCTP_DST = 542,
    OF_OXM_SCTP_DST_MASKED = 543,
    OF_OXM_SCTP_SRC = 544,
    OF_OXM_SCTP_SRC_MASKED = 545,
    OF_OXM_TCP_DST = 546,
    OF_OXM_TCP_DST_MASKED = 547,
    OF_OXM_TCP_SRC = 548,
    OF_OXM_TCP_SRC_MASKED = 549,
    OF_OXM_TUNNEL_ID = 550,
    OF_OXM_TUNNEL_ID_MASKED = 551,
    OF_OXM_TUNNEL_IPV4_DST = 552,
    OF_OXM_TUNNEL_IPV4_DST_MASKED = 553,
    OF_OXM_TUNNEL_IPV4_SRC = 554,
    OF_OXM_TUNNEL_IPV4_SRC_MASKED = 555,
    OF_OXM_UDP_DST = 556,
    OF_OXM_UDP_DST_MASKED = 557,
    OF_OXM_UDP_SRC = 558,
    OF_OXM_UDP_SRC_MASKED = 559,
    OF_OXM_VLAN_PCP = 560,
    OF_OXM_VLAN_PCP_MASKED = 561,
    OF_OXM_VLAN_VID = 562,
    OF_OXM_VLAN_VID_MASKED = 563,
    OF_PACKET_QUEUE = 564,
    OF_PORT_DESC = 565,
    OF_PORT_DESC_PROP = 566,
    OF_PORT_DESC_PROP_BSN = 567,
    OF_PORT_DESC_PROP_BSN_UPLINK = 568,
    OF_PORT_DESC_PROP_ETHERNET = 569,
    OF_PORT_DESC_PROP_EXPERIMENTER = 570,
    OF_PORT_DESC_PROP_OPTICAL = 571,
    OF_PORT_MOD_PROP = 572,
    OF_PORT_MOD_PROP_ETHERNET = 573,
    OF_PORT_MOD_PROP_EXPERIMENTER = 574,
    OF_PORT_MOD_PROP_OPTICAL = 575,
    OF_PORT_STATS_ENTRY = 576,
    OF_PORT_STATS_PROP = 577,
    OF_PORT_STATS_PROP_ETHERNET = 578,
    OF_PORT_STATS_PROP_EXPERIMENTER = 579,
    OF_PORT_STATS_PROP_OPTICAL = 580,
    OF_QUEUE_DESC = 581,
    OF_QUEUE_DESC_PROP = 582,
    OF_QUEUE_DESC_PROP_EXPERIMENTER = 583,
    OF_QUEUE_DESC_PROP_MAX_RATE = 584,
    OF_QUEUE_DESC_PROP_MIN_RATE = 585,
    OF_QUEUE_PROP = 586,
    OF_QUEUE_PROP_EXPERIMENTER = 587,
    OF_QUEUE_PROP_MAX_RATE = 588,
    OF_QUEUE_PROP_MIN_RATE = 589,
    OF_QUEUE_STATS_ENTRY = 590,
    OF_QUEUE_STATS_PROP = 591,
    OF_QUEUE_STATS_PROP_EXPERIMENTER = 592,
    OF_ROLE_PROP = 593,
    OF_ROLE_PROP_EXPERIMENTER = 594,
    OF_TABLE_DESC = 595,
    OF_TABLE_FEATURE_PROP = 596,
    OF_TABLE_FEATURE_PROP_APPLY_ACTIONS = 597,
    OF_TABLE_FEATURE_PROP_APPLY_ACTIONS_MISS = 598,
    OF_TABLE_FEATURE_PROP_APPLY_SETFIELD = 599,
    OF_TABLE_FEATURE_PROP_APPLY_SETFIELD_MISS = 600,
    OF_TABLE_FEATURE_PROP_EXPERIMENTER = 601,
    OF_TABLE_FEATURE_PROP_EXPERIMENTER_MISS = 602,
    OF_TABLE_FEATURE_PROP_INSTRUCTIONS = 603,
    OF_TABLE_FEATURE_PROP_INSTRUCTIONS_MISS = 604,
    OF_TABLE_FEATURE_PROP_MATCH = 605,
    OF_TABLE_FEATURE_PROP_NEXT_TABLES = 606,
    OF_TABLE_FEATURE_PROP_NEXT_TABLES_MISS = 607,
    OF_TABLE_FEATURE_PROP_TABLE_SYNC_FROM = 608,
    OF_TABLE_FEATURE_PROP_WILDCARDS = 609,
    OF_TABLE_FEATURE_PROP_WRITE_ACTIONS = 610,
    OF_TABLE_FEATURE_PROP_WRITE_ACTIONS_MISS = 611,
    OF_TABLE_FEATURE_PROP_WRITE_SETFIELD = 612,
    OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS = 613,
    OF_TABLE_FEATURES = 614,
    OF_TABLE_MOD_PROP = 615,
    OF_TABLE_MOD_PROP_EVICTION = 616,
    OF_TABLE_MOD_PROP_EXPERIMENTER = 617,
    OF_TABLE_MOD_PROP_VACANCY = 618,
    OF_TABLE_STATS_ENTRY = 619,
    OF_UINT32 = 620,
    OF_UINT64 = 621,
    OF_UINT8 = 622,

    /* List objects */
    OF_LIST_ACTION = 623,
    OF_LIST_ACTION_ID = 624,
    OF_LIST_ASYNC_CONFIG_PROP = 625,
    OF_LIST_BSN_CONTROLLER_CONNECTION = 626,
    OF_LIST_BSN_DEBUG_COUNTER_DESC_STATS_ENTRY = 627,
    OF_LIST_BSN_DEBUG_COUNTER_STATS_ENTRY = 628,
    OF_LIST_BSN_FLOW_CHECKSUM_BUCKET_STATS_ENTRY = 629,
    OF_LIST_BSN_GENERIC_STATS_ENTRY = 630,
    OF_LIST_BSN_GENTABLE_BUCKET_STATS_ENTRY = 631,
    OF_LIST_BSN_GENTABLE_DESC_STATS_ENTRY = 632,
    OF_LIST_BSN_GENTABLE_ENTRY_DESC_STATS_ENTRY = 633,
    OF_LIST_BSN_GENTABLE_ENTRY_STATS_ENTRY = 634,
    OF_LIST_BSN_GENTABLE_STATS_ENTRY = 635,
    OF_LIST_BSN_INTERFACE = 636,
    OF_LIST_BSN_LACP_STATS_ENTRY = 637,
    OF_LIST_BSN_PORT_COUNTER_STATS_ENTRY = 638,
    OF_LIST_BSN_SWITCH_PIPELINE_STATS_ENTRY = 639,
    OF_LIST_BSN_TABLE_CHECKSUM_STATS_ENTRY = 640,
    OF_LIST_BSN_TLV = 641,
    OF_LIST_BSN_VLAN_COUNTER_STATS_ENTRY = 642,
    OF_LIST_BSN_VRF_COUNTER_STATS_ENTRY = 643,
    OF_LIST_BUCKET = 644,
    OF_LIST_BUCKET_COUNTER = 645,
    OF_LIST_BUNDLE_PROP = 646,
    OF_LIST_FLOW_STATS_ENTRY = 647,
    OF_LIST_GROUP_DESC_STATS_ENTRY = 648,
    OF_LIST_GROUP_STATS_ENTRY = 649,
    OF_LIST_HELLO_ELEM = 650,
    OF_LIST_INSTRUCTION = 651,
    OF_LIST_INSTRUCTION_ID = 652,
    OF_LIST_METER_BAND = 653,
    OF_LIST_METER_BAND_STATS = 654,
    OF_LIST_METER_STATS = 655,
    OF_LIST_OXM = 656,
    OF_LIST_PACKET_QUEUE = 657,
    OF_LIST_PORT_DESC = 658,
    OF_LIST_PORT_DESC_PROP = 659,
    OF_LIST_PORT_MOD_PROP = 660,
    OF_LIST_PORT_STATS_ENTRY = 661,
    OF_LIST_PORT_STATS_PROP = 662,
    OF_LIST_QUEUE_DESC = 663,
    OF_LIST_QUEUE_DESC_PROP = 664,
    OF_LIST_QUEUE_PROP = 665,
    OF_LIST_QUEUE_STATS_ENTRY = 666,
    OF_LIST_QUEUE_STATS_PROP = 667,
    OF_LIST_ROLE_PROP = 668,
    OF_LIST_TABLE_DESC = 669,
    OF_LIST_TABLE_FEATURE_PROP = 670,
    OF_LIST_TABLE_FEATURES = 671,
    OF_LIST_TABLE_MOD_PROP = 672,
    OF_LIST_TABLE_STATS_ENTRY = 673,
    OF_LIST_UINT32 = 674,
    OF_LIST_UINT64 = 675,
    OF_LIST_UINT8 = 676,

    OF_OBJECT_COUNT = 677
} of_object_id_t;

extern const char *const of_object_id_str[];

#define OF_MESSAGE_OBJECT_COUNT 201

/****************************************************************
 *
 * Experimenter IDs
 *
 ****************************************************************/

#define OF_EXPERIMENTER_ID_OPENFLOW 0x000026e1
#define OF_EXPERIMENTER_ID_NICIRA 0x00002320
#define OF_EXPERIMENTER_ID_BSN 0x005c16c7

/****************************************************************
 *
 * OpenFlow Match version specific and generic defines
 *
 ****************************************************************/

/**
 * Definitions to coerce v4 match (version 1.3) to v3 matches
 * (version 1.2).
 * @FIXME This is a stopgap and needs to get cleaned up.
 */
#define of_match_v4_t of_match_v3_t
#define of_match_v4_init of_match_v3_init
#define of_match_v4_new of_match_v3_new
#define of_match_v4_to_match of_match_v3_to_match
#define of_match_to_wire_match_v4 of_match_to_wire_match_v3
#define of_match_v4_delete of_match_v3_delete

#define of_match_v5_t of_match_v3_t
#define of_match_v5_init of_match_v3_init
#define of_match_v5_new of_match_v3_new
#define of_match_v5_to_match of_match_v3_to_match
#define of_match_to_wire_match_v5 of_match_to_wire_match_v3
#define of_match_v5_delete of_match_v3_delete


/**
 * Definitions for wildcard macros for OF_VERSION_1_0
 */


#define OF_MATCH_V1_WC_ETH_DST_SHIFT 3
#define OF_MATCH_V1_WC_ETH_DST_MASK (1 << 3)
#define OF_MATCH_V1_WC_ETH_DST_SET(wc) ((wc) |= (1 << 3))
#define OF_MATCH_V1_WC_ETH_DST_CLEAR(wc) ((wc) &= ~(1 << 3))
#define OF_MATCH_V1_WC_ETH_DST_TEST(wc) ((wc) & (1 << 3))

#define OF_MATCH_V1_WC_ETH_SRC_SHIFT 2
#define OF_MATCH_V1_WC_ETH_SRC_MASK (1 << 2)
#define OF_MATCH_V1_WC_ETH_SRC_SET(wc) ((wc) |= (1 << 2))
#define OF_MATCH_V1_WC_ETH_SRC_CLEAR(wc) ((wc) &= ~(1 << 2))
#define OF_MATCH_V1_WC_ETH_SRC_TEST(wc) ((wc) & (1 << 2))

#define OF_MATCH_V1_WC_ETH_TYPE_SHIFT 4
#define OF_MATCH_V1_WC_ETH_TYPE_MASK (1 << 4)
#define OF_MATCH_V1_WC_ETH_TYPE_SET(wc) ((wc) |= (1 << 4))
#define OF_MATCH_V1_WC_ETH_TYPE_CLEAR(wc) ((wc) &= ~(1 << 4))
#define OF_MATCH_V1_WC_ETH_TYPE_TEST(wc) ((wc) & (1 << 4))

#define OF_MATCH_V1_WC_IN_PORT_SHIFT 0
#define OF_MATCH_V1_WC_IN_PORT_MASK (1 << 0)
#define OF_MATCH_V1_WC_IN_PORT_SET(wc) ((wc) |= (1 << 0))
#define OF_MATCH_V1_WC_IN_PORT_CLEAR(wc) ((wc) &= ~(1 << 0))
#define OF_MATCH_V1_WC_IN_PORT_TEST(wc) ((wc) & (1 << 0))

#define OF_MATCH_V1_WC_IPV4_DST_SHIFT 14
#define OF_MATCH_V1_WC_IPV4_DST_MASK (0x3f << 14)
#define OF_MATCH_V1_WC_IPV4_DST_CLEAR(wc) ((wc) &= ~(0x3f << 14))
#define OF_MATCH_V1_WC_IPV4_DST_SET(wc, value) do {   \
        OF_MATCH_V1_WC_IPV4_DST_CLEAR(wc); \
        ((wc) |= (((value) & 0x3f) << 14)); \
    } while (0)
#define OF_MATCH_V1_WC_IPV4_DST_TEST(wc) ((wc) & (0x3f << 14))
#define OF_MATCH_V1_WC_IPV4_DST_GET(wc) (((wc) >> 14) & 0x3f)

#define OF_MATCH_V1_WC_IP_PROTO_SHIFT 5
#define OF_MATCH_V1_WC_IP_PROTO_MASK (1 << 5)
#define OF_MATCH_V1_WC_IP_PROTO_SET(wc) ((wc) |= (1 << 5))
#define OF_MATCH_V1_WC_IP_PROTO_CLEAR(wc) ((wc) &= ~(1 << 5))
#define OF_MATCH_V1_WC_IP_PROTO_TEST(wc) ((wc) & (1 << 5))

#define OF_MATCH_V1_WC_IPV4_SRC_SHIFT 8
#define OF_MATCH_V1_WC_IPV4_SRC_MASK (0x3f << 8)
#define OF_MATCH_V1_WC_IPV4_SRC_CLEAR(wc) ((wc) &= ~(0x3f << 8))
#define OF_MATCH_V1_WC_IPV4_SRC_SET(wc, value) do {   \
        OF_MATCH_V1_WC_IPV4_SRC_CLEAR(wc); \
        ((wc) |= (((value) & 0x3f) << 8)); \
    } while (0)
#define OF_MATCH_V1_WC_IPV4_SRC_TEST(wc) ((wc) & (0x3f << 8))
#define OF_MATCH_V1_WC_IPV4_SRC_GET(wc) (((wc) >> 8) & 0x3f)

#define OF_MATCH_V1_WC_IP_DSCP_SHIFT 21
#define OF_MATCH_V1_WC_IP_DSCP_MASK (1 << 21)
#define OF_MATCH_V1_WC_IP_DSCP_SET(wc) ((wc) |= (1 << 21))
#define OF_MATCH_V1_WC_IP_DSCP_CLEAR(wc) ((wc) &= ~(1 << 21))
#define OF_MATCH_V1_WC_IP_DSCP_TEST(wc) ((wc) & (1 << 21))

#define OF_MATCH_V1_WC_TCP_DST_SHIFT 7
#define OF_MATCH_V1_WC_TCP_DST_MASK (1 << 7)
#define OF_MATCH_V1_WC_TCP_DST_SET(wc) ((wc) |= (1 << 7))
#define OF_MATCH_V1_WC_TCP_DST_CLEAR(wc) ((wc) &= ~(1 << 7))
#define OF_MATCH_V1_WC_TCP_DST_TEST(wc) ((wc) & (1 << 7))

#define OF_MATCH_V1_WC_TCP_SRC_SHIFT 6
#define OF_MATCH_V1_WC_TCP_SRC_MASK (1 << 6)
#define OF_MATCH_V1_WC_TCP_SRC_SET(wc) ((wc) |= (1 << 6))
#define OF_MATCH_V1_WC_TCP_SRC_CLEAR(wc) ((wc) &= ~(1 << 6))
#define OF_MATCH_V1_WC_TCP_SRC_TEST(wc) ((wc) & (1 << 6))

#define OF_MATCH_V1_WC_VLAN_PCP_SHIFT 20
#define OF_MATCH_V1_WC_VLAN_PCP_MASK (1 << 20)
#define OF_MATCH_V1_WC_VLAN_PCP_SET(wc) ((wc) |= (1 << 20))
#define OF_MATCH_V1_WC_VLAN_PCP_CLEAR(wc) ((wc) &= ~(1 << 20))
#define OF_MATCH_V1_WC_VLAN_PCP_TEST(wc) ((wc) & (1 << 20))

#define OF_MATCH_V1_WC_VLAN_VID_SHIFT 1
#define OF_MATCH_V1_WC_VLAN_VID_MASK (1 << 1)
#define OF_MATCH_V1_WC_VLAN_VID_SET(wc) ((wc) |= (1 << 1))
#define OF_MATCH_V1_WC_VLAN_VID_CLEAR(wc) ((wc) &= ~(1 << 1))
#define OF_MATCH_V1_WC_VLAN_VID_TEST(wc) ((wc) & (1 << 1))


/**
 * Definitions for wildcard macros for OF_VERSION_1_1
 */

#define OF_MATCH_V2_WC_ETH_TYPE_SHIFT 3
#define OF_MATCH_V2_WC_ETH_TYPE_MASK (1 << 3)
#define OF_MATCH_V2_WC_ETH_TYPE_SET(wc) ((wc) |= (1 << 3))
#define OF_MATCH_V2_WC_ETH_TYPE_CLEAR(wc) ((wc) &= ~(1 << 3))
#define OF_MATCH_V2_WC_ETH_TYPE_TEST(wc) ((wc) & (1 << 3))

#define OF_MATCH_V2_WC_IN_PORT_SHIFT 0
#define OF_MATCH_V2_WC_IN_PORT_MASK (1 << 0)
#define OF_MATCH_V2_WC_IN_PORT_SET(wc) ((wc) |= (1 << 0))
#define OF_MATCH_V2_WC_IN_PORT_CLEAR(wc) ((wc) &= ~(1 << 0))
#define OF_MATCH_V2_WC_IN_PORT_TEST(wc) ((wc) & (1 << 0))

#define OF_MATCH_V2_WC_IP_DSCP_SHIFT 4
#define OF_MATCH_V2_WC_IP_DSCP_MASK (1 << 4)
#define OF_MATCH_V2_WC_IP_DSCP_SET(wc) ((wc) |= (1 << 4))
#define OF_MATCH_V2_WC_IP_DSCP_CLEAR(wc) ((wc) &= ~(1 << 4))
#define OF_MATCH_V2_WC_IP_DSCP_TEST(wc) ((wc) & (1 << 4))

#define OF_MATCH_V2_WC_IP_PROTO_SHIFT 5
#define OF_MATCH_V2_WC_IP_PROTO_MASK (1 << 5)
#define OF_MATCH_V2_WC_IP_PROTO_SET(wc) ((wc) |= (1 << 5))
#define OF_MATCH_V2_WC_IP_PROTO_CLEAR(wc) ((wc) &= ~(1 << 5))
#define OF_MATCH_V2_WC_IP_PROTO_TEST(wc) ((wc) & (1 << 5))

#define OF_MATCH_V2_WC_MPLS_LABEL_SHIFT 8
#define OF_MATCH_V2_WC_MPLS_LABEL_MASK (1 << 8)
#define OF_MATCH_V2_WC_MPLS_LABEL_SET(wc) ((wc) |= (1 << 8))
#define OF_MATCH_V2_WC_MPLS_LABEL_CLEAR(wc) ((wc) &= ~(1 << 8))
#define OF_MATCH_V2_WC_MPLS_LABEL_TEST(wc) ((wc) & (1 << 8))

#define OF_MATCH_V2_WC_MPLS_TC_SHIFT 9
#define OF_MATCH_V2_WC_MPLS_TC_MASK (1 << 9)
#define OF_MATCH_V2_WC_MPLS_TC_SET(wc) ((wc) |= (1 << 9))
#define OF_MATCH_V2_WC_MPLS_TC_CLEAR(wc) ((wc) &= ~(1 << 9))
#define OF_MATCH_V2_WC_MPLS_TC_TEST(wc) ((wc) & (1 << 9))

#define OF_MATCH_V2_WC_TCP_DST_SHIFT 7
#define OF_MATCH_V2_WC_TCP_DST_MASK (1 << 7)
#define OF_MATCH_V2_WC_TCP_DST_SET(wc) ((wc) |= (1 << 7))
#define OF_MATCH_V2_WC_TCP_DST_CLEAR(wc) ((wc) &= ~(1 << 7))
#define OF_MATCH_V2_WC_TCP_DST_TEST(wc) ((wc) & (1 << 7))

#define OF_MATCH_V2_WC_TCP_SRC_SHIFT 6
#define OF_MATCH_V2_WC_TCP_SRC_MASK (1 << 6)
#define OF_MATCH_V2_WC_TCP_SRC_SET(wc) ((wc) |= (1 << 6))
#define OF_MATCH_V2_WC_TCP_SRC_CLEAR(wc) ((wc) &= ~(1 << 6))
#define OF_MATCH_V2_WC_TCP_SRC_TEST(wc) ((wc) & (1 << 6))

#define OF_MATCH_V2_WC_VLAN_PCP_SHIFT 2
#define OF_MATCH_V2_WC_VLAN_PCP_MASK (1 << 2)
#define OF_MATCH_V2_WC_VLAN_PCP_SET(wc) ((wc) |= (1 << 2))
#define OF_MATCH_V2_WC_VLAN_PCP_CLEAR(wc) ((wc) &= ~(1 << 2))
#define OF_MATCH_V2_WC_VLAN_PCP_TEST(wc) ((wc) & (1 << 2))

#define OF_MATCH_V2_WC_VLAN_VID_SHIFT 1
#define OF_MATCH_V2_WC_VLAN_VID_MASK (1 << 1)
#define OF_MATCH_V2_WC_VLAN_VID_SET(wc) ((wc) |= (1 << 1))
#define OF_MATCH_V2_WC_VLAN_VID_CLEAR(wc) ((wc) &= ~(1 << 1))
#define OF_MATCH_V2_WC_VLAN_VID_TEST(wc) ((wc) & (1 << 1))

/*
 * The generic match structure uses the OXM bit indices for it's
 * bitmasks for active and masked values
 */

/* Mask/value check/set macros for ipv6_flabel */

/**
 * Set the mask for an exact match of ipv6_flabel
 */
#define OF_MATCH_MASK_IPV6_FLABEL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_flabel, 0xff, \
        sizeof(((_match)->masks).ipv6_flabel))

/**
 * Clear the mask for ipv6_flabel making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_FLABEL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_flabel, 0, \
        sizeof(((_match)->masks).ipv6_flabel))

/**
 * Test whether the match is exact for ipv6_flabel
 */
#define OF_MATCH_MASK_IPV6_FLABEL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_flabel))

/**
 * Test whether key ipv6_flabel is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_FLABEL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_flabel))


/* Mask/value check/set macros for bsn_lag_id */

/**
 * Set the mask for an exact match of bsn_lag_id
 */
#define OF_MATCH_MASK_BSN_LAG_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_lag_id, 0xff, \
        sizeof(((_match)->masks).bsn_lag_id))

/**
 * Clear the mask for bsn_lag_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_LAG_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_lag_id, 0, \
        sizeof(((_match)->masks).bsn_lag_id))

/**
 * Test whether the match is exact for bsn_lag_id
 */
#define OF_MATCH_MASK_BSN_LAG_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_lag_id))

/**
 * Test whether key bsn_lag_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_LAG_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_lag_id))


/* Mask/value check/set macros for vlan_pcp */

/**
 * Set the mask for an exact match of vlan_pcp
 */
#define OF_MATCH_MASK_VLAN_PCP_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.vlan_pcp, 0xff, \
        sizeof(((_match)->masks).vlan_pcp))

/**
 * Clear the mask for vlan_pcp making that field inactive for the match
 */
#define OF_MATCH_MASK_VLAN_PCP_CLEAR(_match) \
    MEMSET(&(_match)->masks.vlan_pcp, 0, \
        sizeof(((_match)->masks).vlan_pcp))

/**
 * Test whether the match is exact for vlan_pcp
 */
#define OF_MATCH_MASK_VLAN_PCP_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).vlan_pcp))

/**
 * Test whether key vlan_pcp is being checked in the match
 */
#define OF_MATCH_MASK_VLAN_PCP_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).vlan_pcp))


/* Mask/value check/set macros for ipv6_exthdr */

/**
 * Set the mask for an exact match of ipv6_exthdr
 */
#define OF_MATCH_MASK_IPV6_EXTHDR_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_exthdr, 0xff, \
        sizeof(((_match)->masks).ipv6_exthdr))

/**
 * Clear the mask for ipv6_exthdr making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_EXTHDR_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_exthdr, 0, \
        sizeof(((_match)->masks).ipv6_exthdr))

/**
 * Test whether the match is exact for ipv6_exthdr
 */
#define OF_MATCH_MASK_IPV6_EXTHDR_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_exthdr))

/**
 * Test whether key ipv6_exthdr is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_EXTHDR_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_exthdr))


/* Mask/value check/set macros for ipv4_src */

/**
 * Set the mask for an exact match of ipv4_src
 */
#define OF_MATCH_MASK_IPV4_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv4_src, 0xff, \
        sizeof(((_match)->masks).ipv4_src))

/**
 * Clear the mask for ipv4_src making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV4_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv4_src, 0, \
        sizeof(((_match)->masks).ipv4_src))

/**
 * Test whether the match is exact for ipv4_src
 */
#define OF_MATCH_MASK_IPV4_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv4_src))

/**
 * Test whether key ipv4_src is being checked in the match
 */
#define OF_MATCH_MASK_IPV4_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv4_src))


/* Mask/value check/set macros for ipv6_dst */

/**
 * Set the mask for an exact match of ipv6_dst
 */
#define OF_MATCH_MASK_IPV6_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_dst, 0xff, \
        sizeof(((_match)->masks).ipv6_dst))

/**
 * Clear the mask for ipv6_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_dst, 0, \
        sizeof(((_match)->masks).ipv6_dst))

/**
 * Test whether the match is exact for ipv6_dst
 */
#define OF_MATCH_MASK_IPV6_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_dst))

/**
 * Test whether key ipv6_dst is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_dst))


/* Mask/value check/set macros for arp_tpa */

/**
 * Set the mask for an exact match of arp_tpa
 */
#define OF_MATCH_MASK_ARP_TPA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_tpa, 0xff, \
        sizeof(((_match)->masks).arp_tpa))

/**
 * Clear the mask for arp_tpa making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_TPA_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_tpa, 0, \
        sizeof(((_match)->masks).arp_tpa))

/**
 * Test whether the match is exact for arp_tpa
 */
#define OF_MATCH_MASK_ARP_TPA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_tpa))

/**
 * Test whether key arp_tpa is being checked in the match
 */
#define OF_MATCH_MASK_ARP_TPA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_tpa))


/* Mask/value check/set macros for icmpv6_type */

/**
 * Set the mask for an exact match of icmpv6_type
 */
#define OF_MATCH_MASK_ICMPV6_TYPE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.icmpv6_type, 0xff, \
        sizeof(((_match)->masks).icmpv6_type))

/**
 * Clear the mask for icmpv6_type making that field inactive for the match
 */
#define OF_MATCH_MASK_ICMPV6_TYPE_CLEAR(_match) \
    MEMSET(&(_match)->masks.icmpv6_type, 0, \
        sizeof(((_match)->masks).icmpv6_type))

/**
 * Test whether the match is exact for icmpv6_type
 */
#define OF_MATCH_MASK_ICMPV6_TYPE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).icmpv6_type))

/**
 * Test whether key icmpv6_type is being checked in the match
 */
#define OF_MATCH_MASK_ICMPV6_TYPE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).icmpv6_type))


/* Mask/value check/set macros for bsn_in_ports_128 */

/**
 * Set the mask for an exact match of bsn_in_ports_128
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_128_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_in_ports_128, 0xff, \
        sizeof(((_match)->masks).bsn_in_ports_128))

/**
 * Clear the mask for bsn_in_ports_128 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_128_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_in_ports_128, 0, \
        sizeof(((_match)->masks).bsn_in_ports_128))

/**
 * Test whether the match is exact for bsn_in_ports_128
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_128_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_in_ports_128))

/**
 * Test whether key bsn_in_ports_128 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_128_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_in_ports_128))


/* Mask/value check/set macros for arp_sha */

/**
 * Set the mask for an exact match of arp_sha
 */
#define OF_MATCH_MASK_ARP_SHA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_sha, 0xff, \
        sizeof(((_match)->masks).arp_sha))

/**
 * Clear the mask for arp_sha making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_SHA_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_sha, 0, \
        sizeof(((_match)->masks).arp_sha))

/**
 * Test whether the match is exact for arp_sha
 */
#define OF_MATCH_MASK_ARP_SHA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_sha))

/**
 * Test whether key arp_sha is being checked in the match
 */
#define OF_MATCH_MASK_ARP_SHA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_sha))


/* Mask/value check/set macros for ipv6_src */

/**
 * Set the mask for an exact match of ipv6_src
 */
#define OF_MATCH_MASK_IPV6_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_src, 0xff, \
        sizeof(((_match)->masks).ipv6_src))

/**
 * Clear the mask for ipv6_src making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_src, 0, \
        sizeof(((_match)->masks).ipv6_src))

/**
 * Test whether the match is exact for ipv6_src
 */
#define OF_MATCH_MASK_IPV6_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_src))

/**
 * Test whether key ipv6_src is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_src))


/* Mask/value check/set macros for eth_src */

/**
 * Set the mask for an exact match of eth_src
 */
#define OF_MATCH_MASK_ETH_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.eth_src, 0xff, \
        sizeof(((_match)->masks).eth_src))

/**
 * Clear the mask for eth_src making that field inactive for the match
 */
#define OF_MATCH_MASK_ETH_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.eth_src, 0, \
        sizeof(((_match)->masks).eth_src))

/**
 * Test whether the match is exact for eth_src
 */
#define OF_MATCH_MASK_ETH_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).eth_src))

/**
 * Test whether key eth_src is being checked in the match
 */
#define OF_MATCH_MASK_ETH_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).eth_src))


/* Mask/value check/set macros for icmpv6_code */

/**
 * Set the mask for an exact match of icmpv6_code
 */
#define OF_MATCH_MASK_ICMPV6_CODE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.icmpv6_code, 0xff, \
        sizeof(((_match)->masks).icmpv6_code))

/**
 * Clear the mask for icmpv6_code making that field inactive for the match
 */
#define OF_MATCH_MASK_ICMPV6_CODE_CLEAR(_match) \
    MEMSET(&(_match)->masks.icmpv6_code, 0, \
        sizeof(((_match)->masks).icmpv6_code))

/**
 * Test whether the match is exact for icmpv6_code
 */
#define OF_MATCH_MASK_ICMPV6_CODE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).icmpv6_code))

/**
 * Test whether key icmpv6_code is being checked in the match
 */
#define OF_MATCH_MASK_ICMPV6_CODE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).icmpv6_code))


/* Mask/value check/set macros for bsn_in_ports_512 */

/**
 * Set the mask for an exact match of bsn_in_ports_512
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_512_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_in_ports_512, 0xff, \
        sizeof(((_match)->masks).bsn_in_ports_512))

/**
 * Clear the mask for bsn_in_ports_512 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_512_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_in_ports_512, 0, \
        sizeof(((_match)->masks).bsn_in_ports_512))

/**
 * Test whether the match is exact for bsn_in_ports_512
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_512_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_in_ports_512))

/**
 * Test whether key bsn_in_ports_512 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_512_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_in_ports_512))


/* Mask/value check/set macros for mpls_bos */

/**
 * Set the mask for an exact match of mpls_bos
 */
#define OF_MATCH_MASK_MPLS_BOS_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.mpls_bos, 0xff, \
        sizeof(((_match)->masks).mpls_bos))

/**
 * Clear the mask for mpls_bos making that field inactive for the match
 */
#define OF_MATCH_MASK_MPLS_BOS_CLEAR(_match) \
    MEMSET(&(_match)->masks.mpls_bos, 0, \
        sizeof(((_match)->masks).mpls_bos))

/**
 * Test whether the match is exact for mpls_bos
 */
#define OF_MATCH_MASK_MPLS_BOS_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).mpls_bos))

/**
 * Test whether key mpls_bos is being checked in the match
 */
#define OF_MATCH_MASK_MPLS_BOS_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).mpls_bos))


/* Mask/value check/set macros for eth_dst */

/**
 * Set the mask for an exact match of eth_dst
 */
#define OF_MATCH_MASK_ETH_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.eth_dst, 0xff, \
        sizeof(((_match)->masks).eth_dst))

/**
 * Clear the mask for eth_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_ETH_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.eth_dst, 0, \
        sizeof(((_match)->masks).eth_dst))

/**
 * Test whether the match is exact for eth_dst
 */
#define OF_MATCH_MASK_ETH_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).eth_dst))

/**
 * Test whether key eth_dst is being checked in the match
 */
#define OF_MATCH_MASK_ETH_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).eth_dst))


/* Mask/value check/set macros for udp_src */

/**
 * Set the mask for an exact match of udp_src
 */
#define OF_MATCH_MASK_UDP_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.udp_src, 0xff, \
        sizeof(((_match)->masks).udp_src))

/**
 * Clear the mask for udp_src making that field inactive for the match
 */
#define OF_MATCH_MASK_UDP_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.udp_src, 0, \
        sizeof(((_match)->masks).udp_src))

/**
 * Test whether the match is exact for udp_src
 */
#define OF_MATCH_MASK_UDP_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).udp_src))

/**
 * Test whether key udp_src is being checked in the match
 */
#define OF_MATCH_MASK_UDP_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).udp_src))


/* Mask/value check/set macros for ipv4_dst */

/**
 * Set the mask for an exact match of ipv4_dst
 */
#define OF_MATCH_MASK_IPV4_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv4_dst, 0xff, \
        sizeof(((_match)->masks).ipv4_dst))

/**
 * Clear the mask for ipv4_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV4_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv4_dst, 0, \
        sizeof(((_match)->masks).ipv4_dst))

/**
 * Test whether the match is exact for ipv4_dst
 */
#define OF_MATCH_MASK_IPV4_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv4_dst))

/**
 * Test whether key ipv4_dst is being checked in the match
 */
#define OF_MATCH_MASK_IPV4_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv4_dst))


/* Mask/value check/set macros for bsn_udf0 */

/**
 * Set the mask for an exact match of bsn_udf0
 */
#define OF_MATCH_MASK_BSN_UDF0_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf0, 0xff, \
        sizeof(((_match)->masks).bsn_udf0))

/**
 * Clear the mask for bsn_udf0 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF0_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf0, 0, \
        sizeof(((_match)->masks).bsn_udf0))

/**
 * Test whether the match is exact for bsn_udf0
 */
#define OF_MATCH_MASK_BSN_UDF0_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf0))

/**
 * Test whether key bsn_udf0 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF0_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf0))


/* Mask/value check/set macros for bsn_ingress_port_group_id */

/**
 * Set the mask for an exact match of bsn_ingress_port_group_id
 */
#define OF_MATCH_MASK_BSN_INGRESS_PORT_GROUP_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_ingress_port_group_id, 0xff, \
        sizeof(((_match)->masks).bsn_ingress_port_group_id))

/**
 * Clear the mask for bsn_ingress_port_group_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_INGRESS_PORT_GROUP_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_ingress_port_group_id, 0, \
        sizeof(((_match)->masks).bsn_ingress_port_group_id))

/**
 * Test whether the match is exact for bsn_ingress_port_group_id
 */
#define OF_MATCH_MASK_BSN_INGRESS_PORT_GROUP_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_ingress_port_group_id))

/**
 * Test whether key bsn_ingress_port_group_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_INGRESS_PORT_GROUP_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_ingress_port_group_id))


/* Mask/value check/set macros for ipv6_nd_tll */

/**
 * Set the mask for an exact match of ipv6_nd_tll
 */
#define OF_MATCH_MASK_IPV6_ND_TLL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_nd_tll, 0xff, \
        sizeof(((_match)->masks).ipv6_nd_tll))

/**
 * Clear the mask for ipv6_nd_tll making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_ND_TLL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_nd_tll, 0, \
        sizeof(((_match)->masks).ipv6_nd_tll))

/**
 * Test whether the match is exact for ipv6_nd_tll
 */
#define OF_MATCH_MASK_IPV6_ND_TLL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_nd_tll))

/**
 * Test whether key ipv6_nd_tll is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_ND_TLL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_nd_tll))


/* Mask/value check/set macros for tunnel_id */

/**
 * Set the mask for an exact match of tunnel_id
 */
#define OF_MATCH_MASK_TUNNEL_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.tunnel_id, 0xff, \
        sizeof(((_match)->masks).tunnel_id))

/**
 * Clear the mask for tunnel_id making that field inactive for the match
 */
#define OF_MATCH_MASK_TUNNEL_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.tunnel_id, 0, \
        sizeof(((_match)->masks).tunnel_id))

/**
 * Test whether the match is exact for tunnel_id
 */
#define OF_MATCH_MASK_TUNNEL_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).tunnel_id))

/**
 * Test whether key tunnel_id is being checked in the match
 */
#define OF_MATCH_MASK_TUNNEL_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).tunnel_id))


/* Mask/value check/set macros for sctp_src */

/**
 * Set the mask for an exact match of sctp_src
 */
#define OF_MATCH_MASK_SCTP_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.sctp_src, 0xff, \
        sizeof(((_match)->masks).sctp_src))

/**
 * Clear the mask for sctp_src making that field inactive for the match
 */
#define OF_MATCH_MASK_SCTP_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.sctp_src, 0, \
        sizeof(((_match)->masks).sctp_src))

/**
 * Test whether the match is exact for sctp_src
 */
#define OF_MATCH_MASK_SCTP_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).sctp_src))

/**
 * Test whether key sctp_src is being checked in the match
 */
#define OF_MATCH_MASK_SCTP_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).sctp_src))


/* Mask/value check/set macros for bsn_egr_port_group_id */

/**
 * Set the mask for an exact match of bsn_egr_port_group_id
 */
#define OF_MATCH_MASK_BSN_EGR_PORT_GROUP_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_egr_port_group_id, 0xff, \
        sizeof(((_match)->masks).bsn_egr_port_group_id))

/**
 * Clear the mask for bsn_egr_port_group_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_EGR_PORT_GROUP_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_egr_port_group_id, 0, \
        sizeof(((_match)->masks).bsn_egr_port_group_id))

/**
 * Test whether the match is exact for bsn_egr_port_group_id
 */
#define OF_MATCH_MASK_BSN_EGR_PORT_GROUP_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_egr_port_group_id))

/**
 * Test whether key bsn_egr_port_group_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_EGR_PORT_GROUP_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_egr_port_group_id))


/* Mask/value check/set macros for icmpv4_type */

/**
 * Set the mask for an exact match of icmpv4_type
 */
#define OF_MATCH_MASK_ICMPV4_TYPE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.icmpv4_type, 0xff, \
        sizeof(((_match)->masks).icmpv4_type))

/**
 * Clear the mask for icmpv4_type making that field inactive for the match
 */
#define OF_MATCH_MASK_ICMPV4_TYPE_CLEAR(_match) \
    MEMSET(&(_match)->masks.icmpv4_type, 0, \
        sizeof(((_match)->masks).icmpv4_type))

/**
 * Test whether the match is exact for icmpv4_type
 */
#define OF_MATCH_MASK_ICMPV4_TYPE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).icmpv4_type))

/**
 * Test whether key icmpv4_type is being checked in the match
 */
#define OF_MATCH_MASK_ICMPV4_TYPE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).icmpv4_type))


/* Mask/value check/set macros for eth_type */

/**
 * Set the mask for an exact match of eth_type
 */
#define OF_MATCH_MASK_ETH_TYPE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.eth_type, 0xff, \
        sizeof(((_match)->masks).eth_type))

/**
 * Clear the mask for eth_type making that field inactive for the match
 */
#define OF_MATCH_MASK_ETH_TYPE_CLEAR(_match) \
    MEMSET(&(_match)->masks.eth_type, 0, \
        sizeof(((_match)->masks).eth_type))

/**
 * Test whether the match is exact for eth_type
 */
#define OF_MATCH_MASK_ETH_TYPE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).eth_type))

/**
 * Test whether key eth_type is being checked in the match
 */
#define OF_MATCH_MASK_ETH_TYPE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).eth_type))


/* Mask/value check/set macros for arp_op */

/**
 * Set the mask for an exact match of arp_op
 */
#define OF_MATCH_MASK_ARP_OP_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_op, 0xff, \
        sizeof(((_match)->masks).arp_op))

/**
 * Clear the mask for arp_op making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_OP_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_op, 0, \
        sizeof(((_match)->masks).arp_op))

/**
 * Test whether the match is exact for arp_op
 */
#define OF_MATCH_MASK_ARP_OP_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_op))

/**
 * Test whether key arp_op is being checked in the match
 */
#define OF_MATCH_MASK_ARP_OP_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_op))


/* Mask/value check/set macros for mpls_label */

/**
 * Set the mask for an exact match of mpls_label
 */
#define OF_MATCH_MASK_MPLS_LABEL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.mpls_label, 0xff, \
        sizeof(((_match)->masks).mpls_label))

/**
 * Clear the mask for mpls_label making that field inactive for the match
 */
#define OF_MATCH_MASK_MPLS_LABEL_CLEAR(_match) \
    MEMSET(&(_match)->masks.mpls_label, 0, \
        sizeof(((_match)->masks).mpls_label))

/**
 * Test whether the match is exact for mpls_label
 */
#define OF_MATCH_MASK_MPLS_LABEL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).mpls_label))

/**
 * Test whether key mpls_label is being checked in the match
 */
#define OF_MATCH_MASK_MPLS_LABEL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).mpls_label))


/* Mask/value check/set macros for arp_tha */

/**
 * Set the mask for an exact match of arp_tha
 */
#define OF_MATCH_MASK_ARP_THA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_tha, 0xff, \
        sizeof(((_match)->masks).arp_tha))

/**
 * Clear the mask for arp_tha making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_THA_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_tha, 0, \
        sizeof(((_match)->masks).arp_tha))

/**
 * Test whether the match is exact for arp_tha
 */
#define OF_MATCH_MASK_ARP_THA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_tha))

/**
 * Test whether key arp_tha is being checked in the match
 */
#define OF_MATCH_MASK_ARP_THA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_tha))


/* Mask/value check/set macros for in_port */

/**
 * Set the mask for an exact match of in_port
 */
#define OF_MATCH_MASK_IN_PORT_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.in_port, 0xff, \
        sizeof(((_match)->masks).in_port))

/**
 * Clear the mask for in_port making that field inactive for the match
 */
#define OF_MATCH_MASK_IN_PORT_CLEAR(_match) \
    MEMSET(&(_match)->masks.in_port, 0, \
        sizeof(((_match)->masks).in_port))

/**
 * Test whether the match is exact for in_port
 */
#define OF_MATCH_MASK_IN_PORT_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).in_port))

/**
 * Test whether key in_port is being checked in the match
 */
#define OF_MATCH_MASK_IN_PORT_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).in_port))


/* Mask/value check/set macros for bsn_l3_interface_class_id */

/**
 * Set the mask for an exact match of bsn_l3_interface_class_id
 */
#define OF_MATCH_MASK_BSN_L3_INTERFACE_CLASS_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_l3_interface_class_id, 0xff, \
        sizeof(((_match)->masks).bsn_l3_interface_class_id))

/**
 * Clear the mask for bsn_l3_interface_class_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_L3_INTERFACE_CLASS_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_l3_interface_class_id, 0, \
        sizeof(((_match)->masks).bsn_l3_interface_class_id))

/**
 * Test whether the match is exact for bsn_l3_interface_class_id
 */
#define OF_MATCH_MASK_BSN_L3_INTERFACE_CLASS_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_l3_interface_class_id))

/**
 * Test whether key bsn_l3_interface_class_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_L3_INTERFACE_CLASS_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_l3_interface_class_id))


/* Mask/value check/set macros for tcp_dst */

/**
 * Set the mask for an exact match of tcp_dst
 */
#define OF_MATCH_MASK_TCP_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.tcp_dst, 0xff, \
        sizeof(((_match)->masks).tcp_dst))

/**
 * Clear the mask for tcp_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_TCP_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.tcp_dst, 0, \
        sizeof(((_match)->masks).tcp_dst))

/**
 * Test whether the match is exact for tcp_dst
 */
#define OF_MATCH_MASK_TCP_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).tcp_dst))

/**
 * Test whether key tcp_dst is being checked in the match
 */
#define OF_MATCH_MASK_TCP_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).tcp_dst))


/* Mask/value check/set macros for tcp_src */

/**
 * Set the mask for an exact match of tcp_src
 */
#define OF_MATCH_MASK_TCP_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.tcp_src, 0xff, \
        sizeof(((_match)->masks).tcp_src))

/**
 * Clear the mask for tcp_src making that field inactive for the match
 */
#define OF_MATCH_MASK_TCP_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.tcp_src, 0, \
        sizeof(((_match)->masks).tcp_src))

/**
 * Test whether the match is exact for tcp_src
 */
#define OF_MATCH_MASK_TCP_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).tcp_src))

/**
 * Test whether key tcp_src is being checked in the match
 */
#define OF_MATCH_MASK_TCP_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).tcp_src))


/* Mask/value check/set macros for tunnel_ipv4_dst */

/**
 * Set the mask for an exact match of tunnel_ipv4_dst
 */
#define OF_MATCH_MASK_TUNNEL_IPV4_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.tunnel_ipv4_dst, 0xff, \
        sizeof(((_match)->masks).tunnel_ipv4_dst))

/**
 * Clear the mask for tunnel_ipv4_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_TUNNEL_IPV4_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.tunnel_ipv4_dst, 0, \
        sizeof(((_match)->masks).tunnel_ipv4_dst))

/**
 * Test whether the match is exact for tunnel_ipv4_dst
 */
#define OF_MATCH_MASK_TUNNEL_IPV4_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).tunnel_ipv4_dst))

/**
 * Test whether key tunnel_ipv4_dst is being checked in the match
 */
#define OF_MATCH_MASK_TUNNEL_IPV4_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).tunnel_ipv4_dst))


/* Mask/value check/set macros for icmpv4_code */

/**
 * Set the mask for an exact match of icmpv4_code
 */
#define OF_MATCH_MASK_ICMPV4_CODE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.icmpv4_code, 0xff, \
        sizeof(((_match)->masks).icmpv4_code))

/**
 * Clear the mask for icmpv4_code making that field inactive for the match
 */
#define OF_MATCH_MASK_ICMPV4_CODE_CLEAR(_match) \
    MEMSET(&(_match)->masks.icmpv4_code, 0, \
        sizeof(((_match)->masks).icmpv4_code))

/**
 * Test whether the match is exact for icmpv4_code
 */
#define OF_MATCH_MASK_ICMPV4_CODE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).icmpv4_code))

/**
 * Test whether key icmpv4_code is being checked in the match
 */
#define OF_MATCH_MASK_ICMPV4_CODE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).icmpv4_code))


/* Mask/value check/set macros for sctp_dst */

/**
 * Set the mask for an exact match of sctp_dst
 */
#define OF_MATCH_MASK_SCTP_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.sctp_dst, 0xff, \
        sizeof(((_match)->masks).sctp_dst))

/**
 * Clear the mask for sctp_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_SCTP_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.sctp_dst, 0, \
        sizeof(((_match)->masks).sctp_dst))

/**
 * Test whether the match is exact for sctp_dst
 */
#define OF_MATCH_MASK_SCTP_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).sctp_dst))

/**
 * Test whether key sctp_dst is being checked in the match
 */
#define OF_MATCH_MASK_SCTP_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).sctp_dst))


/* Mask/value check/set macros for vlan_vid */

/**
 * Set the mask for an exact match of vlan_vid
 */
#define OF_MATCH_MASK_VLAN_VID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.vlan_vid, 0xff, \
        sizeof(((_match)->masks).vlan_vid))

/**
 * Clear the mask for vlan_vid making that field inactive for the match
 */
#define OF_MATCH_MASK_VLAN_VID_CLEAR(_match) \
    MEMSET(&(_match)->masks.vlan_vid, 0, \
        sizeof(((_match)->masks).vlan_vid))

/**
 * Test whether the match is exact for vlan_vid
 */
#define OF_MATCH_MASK_VLAN_VID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).vlan_vid))

/**
 * Test whether key vlan_vid is being checked in the match
 */
#define OF_MATCH_MASK_VLAN_VID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).vlan_vid))


/* Mask/value check/set macros for bsn_l3_src_class_id */

/**
 * Set the mask for an exact match of bsn_l3_src_class_id
 */
#define OF_MATCH_MASK_BSN_L3_SRC_CLASS_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_l3_src_class_id, 0xff, \
        sizeof(((_match)->masks).bsn_l3_src_class_id))

/**
 * Clear the mask for bsn_l3_src_class_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_L3_SRC_CLASS_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_l3_src_class_id, 0, \
        sizeof(((_match)->masks).bsn_l3_src_class_id))

/**
 * Test whether the match is exact for bsn_l3_src_class_id
 */
#define OF_MATCH_MASK_BSN_L3_SRC_CLASS_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_l3_src_class_id))

/**
 * Test whether key bsn_l3_src_class_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_L3_SRC_CLASS_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_l3_src_class_id))


/* Mask/value check/set macros for bsn_vrf */

/**
 * Set the mask for an exact match of bsn_vrf
 */
#define OF_MATCH_MASK_BSN_VRF_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_vrf, 0xff, \
        sizeof(((_match)->masks).bsn_vrf))

/**
 * Clear the mask for bsn_vrf making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_VRF_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_vrf, 0, \
        sizeof(((_match)->masks).bsn_vrf))

/**
 * Test whether the match is exact for bsn_vrf
 */
#define OF_MATCH_MASK_BSN_VRF_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_vrf))

/**
 * Test whether key bsn_vrf is being checked in the match
 */
#define OF_MATCH_MASK_BSN_VRF_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_vrf))


/* Mask/value check/set macros for arp_spa */

/**
 * Set the mask for an exact match of arp_spa
 */
#define OF_MATCH_MASK_ARP_SPA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_spa, 0xff, \
        sizeof(((_match)->masks).arp_spa))

/**
 * Clear the mask for arp_spa making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_SPA_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_spa, 0, \
        sizeof(((_match)->masks).arp_spa))

/**
 * Test whether the match is exact for arp_spa
 */
#define OF_MATCH_MASK_ARP_SPA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_spa))

/**
 * Test whether key arp_spa is being checked in the match
 */
#define OF_MATCH_MASK_ARP_SPA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_spa))


/* Mask/value check/set macros for ip_proto */

/**
 * Set the mask for an exact match of ip_proto
 */
#define OF_MATCH_MASK_IP_PROTO_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ip_proto, 0xff, \
        sizeof(((_match)->masks).ip_proto))

/**
 * Clear the mask for ip_proto making that field inactive for the match
 */
#define OF_MATCH_MASK_IP_PROTO_CLEAR(_match) \
    MEMSET(&(_match)->masks.ip_proto, 0, \
        sizeof(((_match)->masks).ip_proto))

/**
 * Test whether the match is exact for ip_proto
 */
#define OF_MATCH_MASK_IP_PROTO_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ip_proto))

/**
 * Test whether key ip_proto is being checked in the match
 */
#define OF_MATCH_MASK_IP_PROTO_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ip_proto))


/* Mask/value check/set macros for ip_ecn */

/**
 * Set the mask for an exact match of ip_ecn
 */
#define OF_MATCH_MASK_IP_ECN_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ip_ecn, 0xff, \
        sizeof(((_match)->masks).ip_ecn))

/**
 * Clear the mask for ip_ecn making that field inactive for the match
 */
#define OF_MATCH_MASK_IP_ECN_CLEAR(_match) \
    MEMSET(&(_match)->masks.ip_ecn, 0, \
        sizeof(((_match)->masks).ip_ecn))

/**
 * Test whether the match is exact for ip_ecn
 */
#define OF_MATCH_MASK_IP_ECN_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ip_ecn))

/**
 * Test whether key ip_ecn is being checked in the match
 */
#define OF_MATCH_MASK_IP_ECN_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ip_ecn))


/* Mask/value check/set macros for pbb_uca */

/**
 * Set the mask for an exact match of pbb_uca
 */
#define OF_MATCH_MASK_PBB_UCA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.pbb_uca, 0xff, \
        sizeof(((_match)->masks).pbb_uca))

/**
 * Clear the mask for pbb_uca making that field inactive for the match
 */
#define OF_MATCH_MASK_PBB_UCA_CLEAR(_match) \
    MEMSET(&(_match)->masks.pbb_uca, 0, \
        sizeof(((_match)->masks).pbb_uca))

/**
 * Test whether the match is exact for pbb_uca
 */
#define OF_MATCH_MASK_PBB_UCA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).pbb_uca))

/**
 * Test whether key pbb_uca is being checked in the match
 */
#define OF_MATCH_MASK_PBB_UCA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).pbb_uca))


/* Mask/value check/set macros for tunnel_ipv4_src */

/**
 * Set the mask for an exact match of tunnel_ipv4_src
 */
#define OF_MATCH_MASK_TUNNEL_IPV4_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.tunnel_ipv4_src, 0xff, \
        sizeof(((_match)->masks).tunnel_ipv4_src))

/**
 * Clear the mask for tunnel_ipv4_src making that field inactive for the match
 */
#define OF_MATCH_MASK_TUNNEL_IPV4_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.tunnel_ipv4_src, 0, \
        sizeof(((_match)->masks).tunnel_ipv4_src))

/**
 * Test whether the match is exact for tunnel_ipv4_src
 */
#define OF_MATCH_MASK_TUNNEL_IPV4_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).tunnel_ipv4_src))

/**
 * Test whether key tunnel_ipv4_src is being checked in the match
 */
#define OF_MATCH_MASK_TUNNEL_IPV4_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).tunnel_ipv4_src))


/* Mask/value check/set macros for bsn_global_vrf_allowed */

/**
 * Set the mask for an exact match of bsn_global_vrf_allowed
 */
#define OF_MATCH_MASK_BSN_GLOBAL_VRF_ALLOWED_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_global_vrf_allowed, 0xff, \
        sizeof(((_match)->masks).bsn_global_vrf_allowed))

/**
 * Clear the mask for bsn_global_vrf_allowed making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_GLOBAL_VRF_ALLOWED_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_global_vrf_allowed, 0, \
        sizeof(((_match)->masks).bsn_global_vrf_allowed))

/**
 * Test whether the match is exact for bsn_global_vrf_allowed
 */
#define OF_MATCH_MASK_BSN_GLOBAL_VRF_ALLOWED_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_global_vrf_allowed))

/**
 * Test whether key bsn_global_vrf_allowed is being checked in the match
 */
#define OF_MATCH_MASK_BSN_GLOBAL_VRF_ALLOWED_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_global_vrf_allowed))


/* Mask/value check/set macros for udp_dst */

/**
 * Set the mask for an exact match of udp_dst
 */
#define OF_MATCH_MASK_UDP_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.udp_dst, 0xff, \
        sizeof(((_match)->masks).udp_dst))

/**
 * Clear the mask for udp_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_UDP_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.udp_dst, 0, \
        sizeof(((_match)->masks).udp_dst))

/**
 * Test whether the match is exact for udp_dst
 */
#define OF_MATCH_MASK_UDP_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).udp_dst))

/**
 * Test whether key udp_dst is being checked in the match
 */
#define OF_MATCH_MASK_UDP_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).udp_dst))


/* Mask/value check/set macros for ipv6_nd_target */

/**
 * Set the mask for an exact match of ipv6_nd_target
 */
#define OF_MATCH_MASK_IPV6_ND_TARGET_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_nd_target, 0xff, \
        sizeof(((_match)->masks).ipv6_nd_target))

/**
 * Clear the mask for ipv6_nd_target making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_ND_TARGET_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_nd_target, 0, \
        sizeof(((_match)->masks).ipv6_nd_target))

/**
 * Test whether the match is exact for ipv6_nd_target
 */
#define OF_MATCH_MASK_IPV6_ND_TARGET_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_nd_target))

/**
 * Test whether key ipv6_nd_target is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_ND_TARGET_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_nd_target))


/* Mask/value check/set macros for in_phy_port */

/**
 * Set the mask for an exact match of in_phy_port
 */
#define OF_MATCH_MASK_IN_PHY_PORT_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.in_phy_port, 0xff, \
        sizeof(((_match)->masks).in_phy_port))

/**
 * Clear the mask for in_phy_port making that field inactive for the match
 */
#define OF_MATCH_MASK_IN_PHY_PORT_CLEAR(_match) \
    MEMSET(&(_match)->masks.in_phy_port, 0, \
        sizeof(((_match)->masks).in_phy_port))

/**
 * Test whether the match is exact for in_phy_port
 */
#define OF_MATCH_MASK_IN_PHY_PORT_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).in_phy_port))

/**
 * Test whether key in_phy_port is being checked in the match
 */
#define OF_MATCH_MASK_IN_PHY_PORT_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).in_phy_port))


/* Mask/value check/set macros for ipv6_nd_sll */

/**
 * Set the mask for an exact match of ipv6_nd_sll
 */
#define OF_MATCH_MASK_IPV6_ND_SLL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_nd_sll, 0xff, \
        sizeof(((_match)->masks).ipv6_nd_sll))

/**
 * Clear the mask for ipv6_nd_sll making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_ND_SLL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_nd_sll, 0, \
        sizeof(((_match)->masks).ipv6_nd_sll))

/**
 * Test whether the match is exact for ipv6_nd_sll
 */
#define OF_MATCH_MASK_IPV6_ND_SLL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_nd_sll))

/**
 * Test whether key ipv6_nd_sll is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_ND_SLL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_nd_sll))


/* Mask/value check/set macros for bsn_vlan_xlate_port_group_id */

/**
 * Set the mask for an exact match of bsn_vlan_xlate_port_group_id
 */
#define OF_MATCH_MASK_BSN_VLAN_XLATE_PORT_GROUP_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_vlan_xlate_port_group_id, 0xff, \
        sizeof(((_match)->masks).bsn_vlan_xlate_port_group_id))

/**
 * Clear the mask for bsn_vlan_xlate_port_group_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_VLAN_XLATE_PORT_GROUP_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_vlan_xlate_port_group_id, 0, \
        sizeof(((_match)->masks).bsn_vlan_xlate_port_group_id))

/**
 * Test whether the match is exact for bsn_vlan_xlate_port_group_id
 */
#define OF_MATCH_MASK_BSN_VLAN_XLATE_PORT_GROUP_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_vlan_xlate_port_group_id))

/**
 * Test whether key bsn_vlan_xlate_port_group_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_VLAN_XLATE_PORT_GROUP_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_vlan_xlate_port_group_id))


/* Mask/value check/set macros for mpls_tc */

/**
 * Set the mask for an exact match of mpls_tc
 */
#define OF_MATCH_MASK_MPLS_TC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.mpls_tc, 0xff, \
        sizeof(((_match)->masks).mpls_tc))

/**
 * Clear the mask for mpls_tc making that field inactive for the match
 */
#define OF_MATCH_MASK_MPLS_TC_CLEAR(_match) \
    MEMSET(&(_match)->masks.mpls_tc, 0, \
        sizeof(((_match)->masks).mpls_tc))

/**
 * Test whether the match is exact for mpls_tc
 */
#define OF_MATCH_MASK_MPLS_TC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).mpls_tc))

/**
 * Test whether key mpls_tc is being checked in the match
 */
#define OF_MATCH_MASK_MPLS_TC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).mpls_tc))


/* Mask/value check/set macros for metadata */

/**
 * Set the mask for an exact match of metadata
 */
#define OF_MATCH_MASK_METADATA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.metadata, 0xff, \
        sizeof(((_match)->masks).metadata))

/**
 * Clear the mask for metadata making that field inactive for the match
 */
#define OF_MATCH_MASK_METADATA_CLEAR(_match) \
    MEMSET(&(_match)->masks.metadata, 0, \
        sizeof(((_match)->masks).metadata))

/**
 * Test whether the match is exact for metadata
 */
#define OF_MATCH_MASK_METADATA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).metadata))

/**
 * Test whether key metadata is being checked in the match
 */
#define OF_MATCH_MASK_METADATA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).metadata))


/* Mask/value check/set macros for bsn_l2_cache_hit */

/**
 * Set the mask for an exact match of bsn_l2_cache_hit
 */
#define OF_MATCH_MASK_BSN_L2_CACHE_HIT_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_l2_cache_hit, 0xff, \
        sizeof(((_match)->masks).bsn_l2_cache_hit))

/**
 * Clear the mask for bsn_l2_cache_hit making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_L2_CACHE_HIT_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_l2_cache_hit, 0, \
        sizeof(((_match)->masks).bsn_l2_cache_hit))

/**
 * Test whether the match is exact for bsn_l2_cache_hit
 */
#define OF_MATCH_MASK_BSN_L2_CACHE_HIT_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_l2_cache_hit))

/**
 * Test whether key bsn_l2_cache_hit is being checked in the match
 */
#define OF_MATCH_MASK_BSN_L2_CACHE_HIT_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_l2_cache_hit))


/* Mask/value check/set macros for bsn_udf1 */

/**
 * Set the mask for an exact match of bsn_udf1
 */
#define OF_MATCH_MASK_BSN_UDF1_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf1, 0xff, \
        sizeof(((_match)->masks).bsn_udf1))

/**
 * Clear the mask for bsn_udf1 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF1_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf1, 0, \
        sizeof(((_match)->masks).bsn_udf1))

/**
 * Test whether the match is exact for bsn_udf1
 */
#define OF_MATCH_MASK_BSN_UDF1_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf1))

/**
 * Test whether key bsn_udf1 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF1_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf1))


/* Mask/value check/set macros for bsn_l3_dst_class_id */

/**
 * Set the mask for an exact match of bsn_l3_dst_class_id
 */
#define OF_MATCH_MASK_BSN_L3_DST_CLASS_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_l3_dst_class_id, 0xff, \
        sizeof(((_match)->masks).bsn_l3_dst_class_id))

/**
 * Clear the mask for bsn_l3_dst_class_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_L3_DST_CLASS_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_l3_dst_class_id, 0, \
        sizeof(((_match)->masks).bsn_l3_dst_class_id))

/**
 * Test whether the match is exact for bsn_l3_dst_class_id
 */
#define OF_MATCH_MASK_BSN_L3_DST_CLASS_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_l3_dst_class_id))

/**
 * Test whether key bsn_l3_dst_class_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_L3_DST_CLASS_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_l3_dst_class_id))


/* Mask/value check/set macros for bsn_udf3 */

/**
 * Set the mask for an exact match of bsn_udf3
 */
#define OF_MATCH_MASK_BSN_UDF3_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf3, 0xff, \
        sizeof(((_match)->masks).bsn_udf3))

/**
 * Clear the mask for bsn_udf3 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF3_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf3, 0, \
        sizeof(((_match)->masks).bsn_udf3))

/**
 * Test whether the match is exact for bsn_udf3
 */
#define OF_MATCH_MASK_BSN_UDF3_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf3))

/**
 * Test whether key bsn_udf3 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF3_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf3))


/* Mask/value check/set macros for bsn_udf2 */

/**
 * Set the mask for an exact match of bsn_udf2
 */
#define OF_MATCH_MASK_BSN_UDF2_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf2, 0xff, \
        sizeof(((_match)->masks).bsn_udf2))

/**
 * Clear the mask for bsn_udf2 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF2_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf2, 0, \
        sizeof(((_match)->masks).bsn_udf2))

/**
 * Test whether the match is exact for bsn_udf2
 */
#define OF_MATCH_MASK_BSN_UDF2_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf2))

/**
 * Test whether key bsn_udf2 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF2_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf2))


/* Mask/value check/set macros for bsn_udf5 */

/**
 * Set the mask for an exact match of bsn_udf5
 */
#define OF_MATCH_MASK_BSN_UDF5_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf5, 0xff, \
        sizeof(((_match)->masks).bsn_udf5))

/**
 * Clear the mask for bsn_udf5 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF5_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf5, 0, \
        sizeof(((_match)->masks).bsn_udf5))

/**
 * Test whether the match is exact for bsn_udf5
 */
#define OF_MATCH_MASK_BSN_UDF5_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf5))

/**
 * Test whether key bsn_udf5 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF5_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf5))


/* Mask/value check/set macros for bsn_udf4 */

/**
 * Set the mask for an exact match of bsn_udf4
 */
#define OF_MATCH_MASK_BSN_UDF4_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf4, 0xff, \
        sizeof(((_match)->masks).bsn_udf4))

/**
 * Clear the mask for bsn_udf4 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF4_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf4, 0, \
        sizeof(((_match)->masks).bsn_udf4))

/**
 * Test whether the match is exact for bsn_udf4
 */
#define OF_MATCH_MASK_BSN_UDF4_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf4))

/**
 * Test whether key bsn_udf4 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF4_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf4))


/* Mask/value check/set macros for bsn_udf7 */

/**
 * Set the mask for an exact match of bsn_udf7
 */
#define OF_MATCH_MASK_BSN_UDF7_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf7, 0xff, \
        sizeof(((_match)->masks).bsn_udf7))

/**
 * Clear the mask for bsn_udf7 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF7_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf7, 0, \
        sizeof(((_match)->masks).bsn_udf7))

/**
 * Test whether the match is exact for bsn_udf7
 */
#define OF_MATCH_MASK_BSN_UDF7_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf7))

/**
 * Test whether key bsn_udf7 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF7_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf7))


/* Mask/value check/set macros for bsn_udf6 */

/**
 * Set the mask for an exact match of bsn_udf6
 */
#define OF_MATCH_MASK_BSN_UDF6_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf6, 0xff, \
        sizeof(((_match)->masks).bsn_udf6))

/**
 * Clear the mask for bsn_udf6 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF6_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf6, 0, \
        sizeof(((_match)->masks).bsn_udf6))

/**
 * Test whether the match is exact for bsn_udf6
 */
#define OF_MATCH_MASK_BSN_UDF6_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf6))

/**
 * Test whether key bsn_udf6 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF6_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf6))


/* Mask/value check/set macros for bsn_tcp_flags */

/**
 * Set the mask for an exact match of bsn_tcp_flags
 */
#define OF_MATCH_MASK_BSN_TCP_FLAGS_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_tcp_flags, 0xff, \
        sizeof(((_match)->masks).bsn_tcp_flags))

/**
 * Clear the mask for bsn_tcp_flags making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_TCP_FLAGS_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_tcp_flags, 0, \
        sizeof(((_match)->masks).bsn_tcp_flags))

/**
 * Test whether the match is exact for bsn_tcp_flags
 */
#define OF_MATCH_MASK_BSN_TCP_FLAGS_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_tcp_flags))

/**
 * Test whether key bsn_tcp_flags is being checked in the match
 */
#define OF_MATCH_MASK_BSN_TCP_FLAGS_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_tcp_flags))


/* Mask/value check/set macros for ip_dscp */

/**
 * Set the mask for an exact match of ip_dscp
 */
#define OF_MATCH_MASK_IP_DSCP_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ip_dscp, 0xff, \
        sizeof(((_match)->masks).ip_dscp))

/**
 * Clear the mask for ip_dscp making that field inactive for the match
 */
#define OF_MATCH_MASK_IP_DSCP_CLEAR(_match) \
    MEMSET(&(_match)->masks.ip_dscp, 0, \
        sizeof(((_match)->masks).ip_dscp))

/**
 * Test whether the match is exact for ip_dscp
 */
#define OF_MATCH_MASK_IP_DSCP_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ip_dscp))

/**
 * Test whether key ip_dscp is being checked in the match
 */
#define OF_MATCH_MASK_IP_DSCP_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ip_dscp))


#endif /* Base header file */
